- apiVersion: tekton.dev/v1beta1
  kind: TriggerTemplate
  metadata:
    name: trigger-template-secure-kube
  spec:
    params:
      - name: repository
        description: The git repo
      - name: branch
        description: the branch for the git repo
        default: test-env
      - name: revision
        description: the git revision/commit for the git repo
        default: ''
      - name: app-name
        description: application name
      - name: fail-on-lint-errors
        description: force failure of task when docker lint errors are found
        default: 'false'
      - name: registry-region
        description: The IBM Cloud region for image registry
      - name: registry-namespace
        description: container registry namespace
      - name: image-name
        description: image name
      - name: path-to-context
        default: .
      - name: path-to-dockerfile
        default: .
      - name: dockerfile
        default: Dockerfile
      - name: build-args
        description: >-
          ibmcloud cr build argument list in the format 'KEY=VALUE' with a
          key-value pair per line.
        default: ''
      - name: fail-on-scanned-issues
        description: force failure of task when vulnerability advisor scan issues are found
        default: 'false'
      - name: deployment-file
        description: file containing the kubernetes deployment definition
        default: deployment.yml
      - name: pipeline-debug
        default: '0'
      - name: cluster-name
        description: the name of the cluster to target
      - name: dev-region
      - name: dev-resource-group
      - name: dev-cluster-namespace
        description: namespace dev
      - name: pr-url
        description: PR url
      - name: apikey
      - name: commit-timestamp
        description: commit timestamp
      - name: scm-type
        description: 'source code type used (github, github-ent, gitlab)'
      - name: project-id
        description: project id
        default: ''
    resourcetemplates:
      - apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: secure-kube-$(uid)-pvc
        spec:
          resources:
            requests:
              storage: 5Gi
          volumeMode: Filesystem
          accessModes:
            - ReadWriteOnce
      - apiVersion: tekton.dev/v1beta1
        kind: PipelineRun
        metadata:
          name: secure-kube-$(uid)
        spec:
          pipelineRef:
            name: secure-kube-pipeline
          params:
            - name: repository
              value: $(params.repository)
            - name: branch
              value: $(params.branch)
            - name: revision
              value: $(params.revision)
            - name: app-name
              value: $(params.app-name)
            - name: fail-on-lint-errors
              value: $(params.fail-on-lint-errors)
            - name: registry-region
              value: $(params.registry-region)
            - name: registry-namespace
              value: $(params.registry-namespace)
            - name: image-name
              value: $(params.image-name)
            - name: path-to-context
              value: $(params.path-to-context)
            - name: path-to-dockerfile
              value: $(params.path-to-dockerfile)
            - name: dockerfile
              value: $(params.dockerfile)
            - name: build-args
              value: $(params.build-args)
            - name: fail-on-scanned-issues
              value: $(params.fail-on-scanned-issues)
            - name: deployment-file
              value: $(params.deployment-file)
            - name: dev-region
              value: $(params.dev-region)
            - name: dev-resource-group
              value: $(params.dev-resource-group)
            - name: cluster-name
              value: $(params.cluster-name)
            - name: dev-cluster-namespace
              value: $(params.dev-cluster-namespace)
            - name: pipeline-debug
              value: $(params.pipeline-debug)
            - name: apikey
              value: $(params.apikey)
            - name: pr-url
              value: $(params.pr-url)
            - name: commit-timestamp
              value: $(params.commit-timestamp)
            - name: scm-type
              value: $(params.scm-type)
            - name: project-id
              value: $(params.project-id)
          workspaces:
            - name: pipeline-ws
              persistentVolumeClaim:
                claimName: secure-kube-$(uid)-pvc
- apiVersion: tekton.dev/v1beta1
  kind: TriggerBinding
  metadata:
    name: trigger-binding-manual
  spec:
    params: null
- apiVersion: tekton.dev/v1beta1
  kind: EventListener
  metadata:
    name: manual-run
  spec:
    triggers:
      - binding:
          name: trigger-binding-manual
        template:
          name: trigger-template-secure-kube
- apiVersion: tekton.dev/v1beta1
  kind: TriggerBinding
  metadata:
    name: github-ent-commit
  spec:
    params:
      - name: branch
        value: $(event.ref)
      - name: commit-id
        value: $(event.after)
      - name: commit-timestamp
        value: $(event.repository.pushed_at)
      - name: repository
        value: $(event.repository.html_url)
      - name: scm-type
        value: github-ent
- apiVersion: tekton.dev/v1beta1
  kind: EventListener
  metadata:
    name: github-ent-commit
  spec:
    triggers:
      - bindings:
          - name: github-ent-commit
        template:
          name: trigger-template-secure-kube
- apiVersion: tekton.dev/v1beta1
  kind: TriggerBinding
  metadata:
    name: github-commit
  spec:
    params:
      - name: branch
        value: $(event.ref)
      - name: commit-id
        value: $(event.after)
      - name: commit-timestamp
        value: $(event.repository.updated_at)
      - name: repository
        value: $(event.repository.html_url)
      - name: scm-type
        value: github
- apiVersion: tekton.dev/v1beta1
  kind: EventListener
  metadata:
    name: github-commit
  spec:
    triggers:
      - bindings:
          - name: github-commit
        template:
          name: trigger-template-secure-kube
- apiVersion: tekton.dev/v1beta1
  kind: TriggerBinding
  metadata:
    name: grit-or-gitlab-commit
  spec:
    params:
      - name: branch
        value: $(event.ref)
      - name: commit-id
        value: $(event.checkout_sha)
      - name: commit-timestamp
        value: '$(event.commits[0].timestamp)'
      - name: repository
        value: $(event.project.http_url)
      - name: scm-type
        value: gitlab
- apiVersion: tekton.dev/v1beta1
  kind: EventListener
  metadata:
    name: grit-or-gitlab-commit
  spec:
    triggers:
      - bindings:
          - name: grit-or-gitlab-commit
        template:
          name: trigger-template-secure-kube
- apiVersion: tekton.dev/v1beta1
  kind: TriggerBinding
  metadata:
    name: bitbucket-commit
  spec:
    params:
      - name: repository
        value: $(event.repository.links.html.href)
      - name: revision
        value: '$(event.push.changes[0].new.target.hash)'
      - name: branch
        value: '$(event.push.changes[0].new.name)'
      - name: commit-timestamp
        value: $(event.pull_request.head.repo.pushed_at)
      - name: commit-id
        value: $(event.pull_request.head.sha)
      - name: scm-type
        value: bitbucket
- apiVersion: tekton.dev/v1beta1
  kind: EventListener
  metadata:
    name: bitbucket-commit
  spec:
    triggers:
      - binding:
          name: bitbucket-commit
        template:
          name: trigger-template-secure-kube
- apiVersion: tekton.dev/v1beta1
  kind: Pipeline
  metadata:
    name: secure-kube-pipeline
  spec:
    params:
      - name: repository
        description: >-
          the git repo containing source code. If empty, the repository url will
          be found from toolchain
        default: ''
      - name: branch
        description: the branch for the git repo
        default: test-env
      - name: revision
        description: the git revision/commit for the git repo
        default: ''
      - name: fail-on-lint-errors
        description: force failure of task when docker lint errors are found
        default: 'false'
      - name: fail-on-scanned-issues
        description: force failure of task when vulnerability advisor scan issues are found
        default: 'false'
      - name: path-to-context
        default: .
      - name: path-to-dockerfile
        default: .
      - name: dockerfile
        default: Dockerfile
      - name: build-args
        description: >-
          ibmcloud cr build argument list in the format 'KEY=VALUE' with a
          key-value pair per line.
        default: ''
      - name: registry-region
        description: The IBM Cloud region for image registry
      - name: registry-namespace
        description: container registry namespace
      - name: app-name
        description: application name
      - name: image-name
        description: image name
      - name: deployment-file
        description: file containing the kubernetes deployment definition
        default: deployment.yml
      - name: dev-region
      - name: dev-resource-group
      - name: cluster-name
        description: the name of the cluster to target
      - name: dev-cluster-namespace
        description: the namespace
      - name: pipeline-debug
        default: '0'
      - name: pr-url
        description: pr url
      - name: commit-timestamp
      - name: scm-type
      - name: project-id
        default: ''
    workspaces:
      - name: pipeline-ws
    tasks:
      - name: extract-repository-url
        taskRef:
          name: toolchain-extract-value
        params:
          - name: expression
            value: >-
              . as $toolchain | ["$(params.repository)"] | if .[0]=="" then
              $toolchain | .services[] | select(.toolchain_binding.name=="repo")
              | .dashboard_url else .[0] end
          - name: pipeline-debug
            value: $(params.pipeline-debug)
      - name: git-clone
        taskRef:
          name: git-clone-repo
        params:
          - name: continuous-delivery-context-secret
            value: secure-properties
          - name: ibmcloud-apikey-secret-key
            value: toolchain-apikey
          - name: repository
            value: $(tasks.extract-repository-url.results.extracted-value)
          - name: branch
            value: $(params.branch)
          - name: revision
            value: $(params.revision)
          - name: pipeline-debug
            value: $(params.pipeline-debug)
        workspaces:
          - name: output
            workspace: pipeline-ws
      - name: extract-doi-enablement
        taskRef:
          name: toolchain-extract-value
        params:
          - name: expression
            value: >-
              reduce .services[] as $service (0; if
              $service.service_id=="draservicebroker" then .+1 else . end)
          - name: pipeline-debug
            value: $(params.pipeline-debug)
      - name: publish-doi-buildrecord
        runAfter:
          - extract-doi-enablement
        when:
          - input: $(tasks.extract-doi-enablement.results.extracted-value)
            operator: in
            values:
              - '1'
        taskRef:
          name: doi-publish-buildrecord
        params:
          - name: toolchain-apikey-secret-key
            value: toolchain-apikey
          - name: app-name
            value: $(params.app-name)
          - name: git-repository
            value: $(tasks.git-clone.results.git-repository)
          - name: git-branch
            value: $(tasks.git-clone.results.git-branch)
          - name: git-commit
            value: $(tasks.git-clone.results.git-commit)
      - name: cra-discovery-scan
        runAfter:
          - git-clone
        taskRef:
          name: cra-discovery
        workspaces:
          - name: artifacts
            workspace: pipeline-ws
        params:
          - name: repository
            value: $(tasks.extract-repository-url.results.extracted-value)
          - name: revision
            value: $(params.branch)
          - name: commit-id
            value: $(tasks.git-clone.results.git-commit)
          - name: pipeline-debug
            value: $(params.pipeline-debug)
          - name: directory-name
            value: ''
          - name: commit-timestamp
            value: $(params.commit-timestamp)
      - name: code-vulnerability-scan
        runAfter:
          - cra-discovery-scan
        taskRef:
          name: cra-vulnerability-remediation
        workspaces:
          - name: artifacts
            workspace: pipeline-ws
          - name: secrets
            workspace: pipeline-ws
        params:
          - name: repository
            value: $(tasks.extract-repository-url.results.extracted-value)
          - name: revision
            value: $(params.branch)
          - name: pr-url
            value: $(params.pr-url)
          - name: commit-id
            value: $(tasks.git-clone.results.git-commit)
          - name: scm-type
            value: $(params.scm-type)
          - name: project-id
            value: $(params.project-id)
      - name: cra-cis-check
        taskRef:
          name: cra-cis-check
        runAfter:
          - cra-discovery-scan
        workspaces:
          - name: secrets
            workspace: pipeline-ws
          - name: artifacts
            workspace: pipeline-ws
        params:
          - name: repository
            value: $(tasks.extract-repository-url.results.extracted-value)
          - name: revision
            value: $(params.branch)
          - name: pr-url
            value: $(params.pr-url)
          - name: commit-id
            value: $(tasks.git-clone.results.git-commit)
          - name: directory-name
            value: ''
          - name: scm-type
            value: $(params.scm-type)
          - name: project-id
            value: $(params.project-id)
      - name: cra-bom
        taskRef:
          name: cra-bom
        runAfter:
          - cra-discovery-scan
        workspaces:
          - name: artifacts
            workspace: pipeline-ws
          - name: secrets
            workspace: pipeline-ws
        params:
          - name: repository
            value: $(tasks.extract-repository-url.results.extracted-value)
          - name: revision
            value: $(params.branch)
          - name: pr-url
            value: $(params.pr-url)
          - name: commit-id
            value: $(tasks.git-clone.results.git-commit)
          - name: target-branch
            value: $(params.branch)
          - name: target-commit-id
            value: $(tasks.git-clone.results.git-commit)
          - name: scm-type
            value: $(params.scm-type)
          - name: project-id
            value: $(params.project-id)
      - name: docker-lint
        runAfter:
          - git-clone
        taskRef:
          name: linter-docker-lint
        params:
          - name: path-to-dockerfile
            value: $(params.path-to-dockerfile)
          - name: dockerfile
            value: $(params.dockerfile)
          - name: fail-on-lint-errors
            value: $(params.fail-on-lint-errors)
          - name: pipeline-debug
            value: $(params.pipeline-debug)
        workspaces:
          - name: workspace
            workspace: pipeline-ws
      - name: unit-tests
        runAfter:
          - docker-lint
        taskRef:
          name: tester-run-tests
        params:
          - name: tests-script
            value: |
              if [ -f ./test/run-tests.sh ]; then
                source ./test/run-tests.sh
                echo -n $FILE_LOCATIONS > $(results.test-result-file-paths.path)
                echo -n $TEST_TYPES > $(results.test-types.path)
              else
                echo "Test runner script not found: ./test/run-tests.sh"
              fi
        workspaces:
          - name: artifacts
            workspace: pipeline-ws
      - name: publish-doi-code-tests
        runAfter:
          - unit-tests
        when:
          - input: $(tasks.extract-doi-enablement.results.extracted-value)
            operator: in
            values:
              - '1'
        taskRef:
          name: doi-publish-testrecord
        params:
          - name: toolchain-apikey-secret-key
            value: toolchain-apikey
          - name: build-number
            value: $(tasks.publish-doi-buildrecord.results.build-number)
          - name: app-name
            value: $(params.app-name)
          - name: file-locations
            value: $(tasks.unit-tests.results.test-result-file-paths)
          - name: test-types
            value: $(tasks.unit-tests.results.test-types)
          - name: pipeline-debug
            value: $(params.pipeline-debug)
        workspaces:
          - name: artifacts
            workspace: pipeline-ws
      - name: containerize
        runAfter:
          - unit-tests
        taskRef:
          name: icr-containerize
        params:
          - name: continuous-delivery-context-secret
            value: secure-properties
          - name: container-registry-apikey-secret-key
            value: apikey
          - name: registry-region
            value: $(params.registry-region)
          - name: registry-namespace
            value: $(params.registry-namespace)
          - name: image-name
            value: $(params.image-name)
          - name: path-to-context
            value: $(params.path-to-context)
          - name: path-to-dockerfile
            value: $(params.path-to-dockerfile)
          - name: dockerfile
            value: $(params.dockerfile)
          - name: build-args
            value: $(params.build-args)
          - name: additional-tags-script
            value: >
              # Minting image tag using format:
              BUILD_NUMBER-BRANCH-COMMIT_ID-TIMESTAMP

              # e.g. 3-master-50da6912-20181123114435

              # (use build number as first segment to allow image tag as a patch
              release name according to semantic versioning)

              GIT_BRANCH="$(tasks.git-clone.results.git-branch)"

              GIT_COMMIT="$(tasks.git-clone.results.git-commit)"

              TIMESTAMP=$( date -u "+%Y%m%d%H%M%S")

              IMAGE_TAG=${TIMESTAMP}

              if [ ! -z "${GIT_COMMIT}" ]; then
                GIT_COMMIT_SHORT=$( echo ${GIT_COMMIT} | head -c 8 )
                IMAGE_TAG=${GIT_COMMIT_SHORT}-${IMAGE_TAG}
              fi

              if [ ! -z "${GIT_BRANCH}" ]; then
              IMAGE_TAG=${GIT_BRANCH}-${IMAGE_TAG} ; fi

              IMAGE_TAG=${BUILD_NUMBER}-${IMAGE_TAG}

              echo "$IMAGE_TAG"
          - name: pipeline-debug
            value: $(params.pipeline-debug)
        workspaces:
          - name: source
            workspace: pipeline-ws
      - name: vulnerability-advisor
        taskRef:
          name: icr-check-va-scan
        params:
          - name: continuous-delivery-context-secret
            value: secure-properties
          - name: container-registry-apikey-secret-key
            value: apikey
          - name: scan-report-file
            value: app-image-va-report.json
          - name: fail-on-scanned-issues
            value: $(params.fail-on-scanned-issues)
          - name: pipeline-debug
            value: $(params.pipeline-debug)
          - name: image-url
            value: $(tasks.containerize.results.image-repository)
          - name: image-digest
            value: $(tasks.containerize.results.image-digest)
        workspaces:
          - name: artifacts
            workspace: pipeline-ws
      - name: publish-doi-va-scan-record
        runAfter:
          - vulnerability-advisor
        when:
          - input: $(tasks.extract-doi-enablement.results.extracted-value)
            operator: in
            values:
              - '1'
        taskRef:
          name: doi-publish-testrecord
        params:
          - name: toolchain-apikey-secret-key
            value: toolchain-apikey
          - name: build-number
            value: $(tasks.publish-doi-buildrecord.results.build-number)
          - name: app-name
            value: $(params.app-name)
          - name: file-locations
            value: $(tasks.vulnerability-advisor.results.scan-report-file)
          - name: test-types
            value: vulnerabilityadvisor
          - name: pipeline-debug
            value: $(params.pipeline-debug)
        workspaces:
          - name: artifacts
            workspace: pipeline-ws
      - name: deploy-to-kubernetes
        taskRef:
          name: iks-deploy-to-kubernetes
        runAfter:
          - vulnerability-advisor
        params:
          - name: shuttle-properties-file
            value: build.properties
          - name: cluster-region
            value: $(params.dev-region)
          - name: resource-group
            value: $(params.dev-resource-group)
          - name: cluster-name
            value: $(params.cluster-name)
          - name: setup-script
            value: |
              export CLUSTER_NAMESPACE="$(params.dev-cluster-namespace)"
              export DEPLOYMENT_FILE="$(params.deployment-file)"
              # pipeline build number is the doi build record id (if any)
              export SOURCE_BUILD_NUMBER=$BUILD_NUMBER
              echo "SOURCE_BUILD_NUMBER=$BUILD_NUMBER" >> build.properties
              # For doi plugin invocation if needed
              export TOOLCHAIN_ID=$PIPELINE_TOOLCHAIN_ID
              # Single tag for the image built
              export IMAGE_TAG=$IMAGE_TAGS
              # Keep it in build.properties shuttle file
              echo "IMAGE_TAG=$IMAGE_TAGS" >> build.properties
          - name: script
            value: >
              # uncomment to debug the script

              # set -x

              # copy the script below into your app code repo (e.g.
              ./scripts/check_and_deploy_kubectl.sh) and 'source' it from your
              pipeline job

              #    source ./scripts/check_and_deploy_kubectl.sh

              # alternatively, you can source it from online script:

              #    source <(curl -sSL
              "https://raw.githubusercontent.com/open-toolchain/commons/master/scripts/check_and_deploy_kubectl.sh")

              # ------------------

              # source:
              https://raw.githubusercontent.com/open-toolchain/commons/master/scripts/check_and_deploy_kubectl.sh


              # This script checks the IBM Container Service cluster is ready,
              has a namespace configured with access to the private

              # image registry (using an IBM Cloud API Key), perform a kubectl
              deploy of container image and check on outcome.

              source <(curl -sSL
              "https://raw.githubusercontent.com/open-toolchain/commons/master/scripts/check_and_deploy_kubectl.sh")
          - name: post-execution-script
            value: |
              # Keep APP_URL in build.properties shuttle file
              echo "APP_URL=$APP_URL" >> build.properties
          - name: pipeline-debug
            value: $(params.pipeline-debug)
        workspaces:
          - name: artifacts
            workspace: pipeline-ws
      - name: publish-deployable-task
        runAfter:
          - deploy-to-kubernetes
        taskRef:
          name: toolchain-publish-deployable-mapping
        params:
          - name: deployable-type
            value: kubernetes_cluster
          - name: deployable-region-id
            value: $(tasks.deploy-to-kubernetes.results.region)
          - name: deployable-guid
            value: $(tasks.deploy-to-kubernetes.results.cluster-id)
          - name: deployable-rg-id
            value: $(tasks.deploy-to-kubernetes.results.resource-group-id)
          - name: environment-label
            value: '$(params.cluster-name) namespace:$(params.dev-cluster-namespace)'
          - name: git-inputs
            value: >-
              $(tasks.git-clone.results.git-repository),$(tasks.git-clone.results.git-commit),$(tasks.git-clone.results.git-branch)
          - name: pipeline-debug
            value: $(params.pipeline-debug)
      - name: check-health
        taskRef:
          name: iks-deploy-to-kubernetes
        runAfter:
          - deploy-to-kubernetes
        params:
          - name: shuttle-properties-file
            value: build.properties
          - name: cluster-region
            value: $(params.dev-region)
          - name: resource-group
            value: $(params.dev-resource-group)
          - name: cluster-name
            value: $(params.cluster-name)
          - name: setup-script
            value: |
              export CLUSTER_NAMESPACE="$(params.dev-cluster-namespace)"
          - name: script
            value: >
              # uncomment to debug the script

              # set -x

              # copy the script below into your app code repo (e.g.
              ./scripts/check_health.sh) and 'source' it from your pipeline job

              #    source ./scripts/check_health.sh

              # alternatively, you can source it from online script:

              #    source <(curl -sSL
              "https://raw.githubusercontent.com/open-toolchain/commons/master/scripts/check_health.sh")

              # ------------------

              # source:
              https://raw.githubusercontent.com/open-toolchain/commons/master/scripts/check_health.sh

              # Check liveness and readiness probes to confirm application is
              healthy

              source <(curl -sSL
              "https://raw.githubusercontent.com/open-toolchain/commons/master/scripts/check_health.sh")
          - name: pipeline-debug
            value: $(params.pipeline-debug)
        workspaces:
          - name: artifacts
            workspace: pipeline-ws
- apiVersion: tekton.dev/v1alpha1
  kind: Condition
  metadata:
    name: skip-ci
  spec:
    params:
      - name: commit-message
      - name: skip-ci-pattern
        default: '.*\[\(skip ci\)\|\(ci skip\)\].*'
    check:
      image: alpine
      command:
        - /bin/sh
        - '-c'
      args:
        - echo "$(params.commit-message)" | grep -v '$(params.skip-ci-pattern)'
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: git-clone-repo
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: ibmcloud-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud
        default: apikey
      - name: git-access-token
        description: >
          (optional) token to access the git repository. If this token is
          provided, there will not be an attempt

          to use the git token obtained from the authorization flow when adding
          the git integration in the toolchain
        default: ''
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: repository
        description: the git repo url
      - name: branch
        description: the git branch
        default: master
      - name: revision
        description: |
          the git revision/commit to update the git HEAD to.
          Default is to mean only use the branch
        default: ''
      - name: git-client-image
        description: The image to use to run git clone commands
        default: alpine/git
      - name: git-max-retry
        description: max retry for the git clone operation
        default: '1'
      - name: pr-repository
        description: >
          the originating repository where the PullRequest comes from (in case
          of a fork)

          default to '' means same repository (not a fork) or it can be the same
          as the repository to clone
        default: ''
      - name: pr-branch
        description: |
          the branch that is the source of this PullRequest
        default: ''
      - name: pr-revision
        description: >-
          the commit/revision in the source branch of the PullRequest that is to
          be built
        default: ''
      - name: directory-name
        description: >
          name of the new directory to clone into.

          Default to . in order to clone at the root of the workspace

          It will be set to the "humanish" part of the repository if this param
          is set to blank
        default: .
      - name: properties-file
        description: >-
          file containing properties out of clone task (can be a filepath name
          relative to the workspace)
        default: build.properties
      - name: git-credentials-json-file
        description: >
          JSON file containing the git credentials as found out of the clone
          task

          (can be a file path relative to the workspace).

          Default to '' meaning no output of this information
        default: ''
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    results:
      - name: git-repository
        description: The cloned repository
      - name: git-branch
        description: The active branch for the repository
      - name: git-commit
        description: The current commit id that was cloned
      - name: git-user
        description: The auth user that cloned the repository
    workspaces:
      - name: output
        description: The git repo will be cloned onto the volume backing this workspace
        mountPath: /artifacts
    stepTemplate:
      env:
        - name: API_KEY
          valueFrom:
            secretKeyRef:
              name: $(params.continuous-delivery-context-secret)
              key: $(params.ibmcloud-apikey-secret-key)
              optional: true
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: fetch-git-token
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: REPOSITORY
            value: $(params.repository)
        script: >
          #!/bin/bash

          set -e -o pipefail


          if [ $PIPELINE_DEBUG == 1 ]; then
              pwd
              env
              trap env EXIT
              set -x
          fi


          TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)

          TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json | awk
          -F: '{print $3}')

          ##########################################################################

          # Setting HOME explicitly to have ibmcloud plugins available

          # doing the export rather than env definition is a workaround

          # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

          export HOME="/root"

          ##########################################################################

          if [[ "$REPOSITORY" != *.git ]]; then
            echo "Adding .git suffix to Repository URL"
            REPOSITORY="${REPOSITORY}.git"
          fi

          GIT_SERVICE_INSTANCE_ID=$(jq -r --arg git_repo "$REPOSITORY" \
            '.services[] | select (.parameters.repo_url==$git_repo) | .instance_id' /cd-config/toolchain.json)
          if [ -z "$GIT_SERVICE_INSTANCE_ID" ]; then
            echo "No Git integration (repository url: $REPOSITORY) found in the toolchain"
            exit 1
          fi

          GIT_SERVICE_TYPE=$(jq -r --arg git_repo "$REPOSITORY" \
            '.services[] | select (.parameters.repo_url==$git_repo) | .service_id' /cd-config/toolchain.json)

          if [ "$GIT_SERVICE_TYPE" == "github" ]; then
            GIT_AUTH_USER="x-oauth-basic"
          elif [ "$GIT_SERVICE_TYPE" == "githubpublic" ]; then
            GIT_AUTH_USER="x-oauth-basic"
          elif [ "$GIT_SERVICE_TYPE" == "hostedgit" ]; then
            GIT_AUTH_USER="oauth2"
          elif [ "$GIT_SERVICE_TYPE" == "gitlab" ]; then
            GIT_AUTH_USER="oauth2"
          elif [ "$GIT_SERVICE_TYPE" == "bitbucketgit" ]; then
            GIT_AUTH_USER="x-token-auth"
          else
            GIT_AUTH_USER="x-token-auth"
          fi;


          GIT_TOKEN="$(params.git-access-token)"

          if [ -z "$GIT_TOKEN" ]; then
            echo "Fetching token for $REPOSITORY"
            ibmcloud config --check-version false
            ibmcloud login -a $(params.ibmcloud-api) -r $TOOLCHAIN_REGION --apikey $API_KEY
            if [ "$(params.resource-group)" ]; then
              ibmcloud target -g "$(params.resource-group)"
            fi
            TOKEN=$(ibmcloud iam oauth-tokens --output JSON | jq -r '.iam_token')
            GIT_TOKEN_URL=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.token_url' \
              /cd-config/toolchain.json)

            # GIT_TOKEN_URL is something like
            # https://otc-github-consolidated-broker.us-south.devops.cloud.ibm.com/github/token?git_id=github
            # as there is already an url param git_id, just put the additional ones using &

            GIT_BROKER_URL="${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
            echo "Doing cURL to ${GIT_BROKER_URL}"

            curl -s -o /steps/github_token_result.json -X GET -H "Accept: application/json" \
              -H "Authorization: $TOKEN" "$GIT_BROKER_URL"
            if jq -e '.access_token' /steps/github_token_result.json > /dev/null 2>&1; then
              GIT_TOKEN=$(jq -r '.access_token' /steps/github_token_result.json)
              echo "Access token found for the Git integration (repository url: $REPOSITORY)"
            else
              echo "No access token found for the Git integration (repository url: $REPOSITORY)"
              cat /steps/github_token_result.json
              exit 1
            fi
          else
            echo "Using git Access Token provided"
          fi


          echo "GIT_REPOSITORY=$REPOSITORY" > /steps/next-step-env.properties

          echo "GIT_AUTH_USER=$GIT_AUTH_USER" >> /steps/next-step-env.properties

          echo "GIT_TOKEN=$GIT_TOKEN" >> /steps/next-step-env.properties
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
      - name: clone-repo
        image: $(params.git-client-image)
        env:
          - name: REPOSITORY
            value: $(params.repository)
          - name: BRANCH
            value: $(params.branch)
          - name: REVISION
            value: $(params.revision)
          - name: PR_REPOSITORY
            value: $(params.pr-repository)
          - name: PR_BRANCH
            value: $(params.pr-branch)
          - name: PR_REVISION
            value: $(params.pr-revision)
          - name: DIRECTORY_NAME
            value: $(params.directory-name)
          - name: PROPERTIES_FILE
            value: $(params.properties-file)
          - name: JSON_FILE_GIT_CREDENTIALS
            value: $(params.git-credentials-json-file)
        script: >
          #!/bin/sh

          set -e


          if [ $PIPELINE_DEBUG == 1 ]; then
              pwd
              env
              trap env EXIT
              set -x
          fi


          ############################

          # Workaround until a null/empty param can be flowing to Task

          # REVISION if not set is define with a single blank value

          BRANCH=$(echo $BRANCH)

          REVISION=$(echo $REVISION)

          PR_REPOSITORY=$(echo $PR_REPOSITORY)

          PR_BRANCH=$(echo $PR_BRANCH)

          PR_REVISION=$(echo $PR_REVISION)

          ############################

          source /steps/next-step-env.properties


          # If $BRANCH is a full git ref then only keep the name part

          BRANCH=$(echo ${BRANCH#"refs/heads/"})


          echo "Cloning $REPOSITORY"

          # Add the proper creds to the git repository

          GIT_URL=$(echo "$REPOSITORY" | sed -e
          "s/:\/\//:\/\/$GIT_AUTH_USER:$GIT_TOKEN@/g")

          ARTIFACTS_PATH="$(workspaces.output.path)"

          cd $ARTIFACTS_PATH

          if [ "$REVISION" ]; then
            # check if the branch exists (that may not be the case in case of a pipeline-run re-run)
            echo "Fetching specific -${REVISION}- commit"
            if [ -z "$BRANCH" ]; then
              # No branch provided
              _clone_command='git clone -q -n $GIT_URL $DIRECTORY_NAME'
            elif git ls-remote --heads --exit-code $GIT_URL $BRANCH > /dev/null 2>&1; then
              _clone_command='git clone -q -b "$BRANCH" $GIT_URL $DIRECTORY_NAME'
            else
              echo "branch $BRANCH does not exists in $REPOSITORY"
              _clone_command='git clone -q -n $GIT_URL $DIRECTORY_NAME'
            fi
          else
            if [ -z "$BRANCH" ]; then
              # No branch provided
              echo "No branch or revision provided."
              _clone_command='git clone -q -n $GIT_URL $DIRECTORY_NAME'
            else
              _clone_command='git clone -q -b "$BRANCH" $GIT_URL $DIRECTORY_NAME'
            fi
          fi

          _max_retry=$(params.git-max-retry)

          set +e

          eval "$_clone_command"

          _clone_code=$?

          _retry_counter=1

          while [ $_retry_counter -le $_max_retry ]; do
              if [ $_clone_code != 0 ]; then
                echo "Clone was not successful. Code $_clone_code - Retrying shortly..."
                sleep 10
                if [ $_retry_counter -eq $_max_retry ]; then
                    set -e # reset on the last attempt so we fail if all attemps fail
                fi
                eval "$_clone_command"
                let "_retry_counter++"
              else
                break
              fi
          done

          echo "Repository $REPOSITORY successfully cloned"

          set -e


          current_dir=$(pwd)

          if [ -z "$DIRECTORY_NAME" ]; then
            # Find the "humanish" part of the git source repository that corresponds to the clone directory
            # GIT_REPOSITORY contains the repository url with .git suffix
            DIRECTORY_NAME=$(basename "${GIT_REPOSITORY##*/}" .git)
          fi

          cd $DIRECTORY_NAME

          if [ "$REVISION" ]; then
            # Point the HEAD to the specific revision
            git checkout -q $REVISION
          fi

          GIT_COMMIT=$(git show-ref --head | head -n1 | awk '{print $1}')


          # If a Pull Request/Merge Request branch is specified, then

          # execute the git commands to have the cloned git repository directory
          content

          # to be the result of the merge for pull request/merge request

          if [ "${PR_BRANCH}" ]; then
            echo "Performing Pull Request Checkout & Merge"
            git config --global user.email "cdtektonpipeline@ibm.com"
            git config --global user.name "CD Tekton Pipeline"
            # Clear GIT_COMMIT as the outcome if this task is a non yet known commit
            GIT_COMMIT=""
            if [ -z "$PR_REPOSITORY" ] || [ "$PR_REPOSITORY" == "$REPOSITORY" ]; then
              # Assuming the PR is not coming from a fork as $PR_REPOSITORY is empty or equals to $REPOSITORY
              # Make the manual steps that a merge request action is doing
              git fetch -q origin "${PR_BRANCH}"
              if [ "${PR_REVISION}" ]; then
                if git merge "${PR_REVISION}"; then
                  echo "git merge ${PR_REVISION} done"
                else
                  exit 1
                fi
              else
                if git merge "origin/${PR_BRANCH}"; then
                  echo "git merge origin/${PR_BRANCH} done"
                else
                  exit 1
                fi
              fi
              echo -n "git merge of $GIT_REPOSITORY (pr-branch ${PR_BRANCH} - pr_commit ${PR_REVISION}) to "
              echo "(branch $BRANCH - commit $REVISION) done in directory $DIRECTORY_NAME"
            else
              # Assuming the PR is from a fork
              # Expect that the same creds will be sufficient for the git pull from the forked repository
              GIT_PR_REPO_URL=$(echo "$PR_REPOSITORY" | sed -e "s/:\/\//:\/\/$GIT_AUTH_USER:$GIT_TOKEN@/g")
              # Make the manual steps that a merge request action is doing
              # Step 1
              if git pull "${GIT_PR_REPO_URL}" "${PR_BRANCH}"; then
                echo "git pull ${PR_REPOSITORY} ${PR_BRANCH} done"
              else
                exit 1
              fi
              if [ "$PR_REVISION" ]; then
                git checkout -q "$PR_REVISION"
              fi
              # create a specific branch to hold the PR state
              git checkout -q -b cd-tekton-pipeline-temp-branch-for-pr
              # Step 2
              git checkout -q "${BRANCH}"
              if git merge cd-tekton-pipeline-temp-branch-for-pr; then
                echo -n "git merge of $PR_REPOSITORY (pr-branch ${PR_BRANCH} - pr_commit ${PR_REVISION}) to $REPOSITORY"
                echo " (branch $BRANCH - commit $REVISION) done in directory $DIRECTORY_NAME"
              else
                exit 1
              fi
            fi
          else
            echo "git clone of $GIT_REPOSITORY (branch $BRANCH - commit $GIT_COMMIT) done in directory $DIRECTORY_NAME"
          fi

          cd $current_dir

          if [ "$PROPERTIES_FILE" ]; then
            # Ensure directory is there
            mkdir -p $ARTIFACTS_PATH/$(dirname "$PROPERTIES_FILE")
            echo "GIT_URL=$REPOSITORY" >> $ARTIFACTS_PATH/$PROPERTIES_FILE
            echo "GIT_BRANCH=$BRANCH" >> $ARTIFACTS_PATH/$PROPERTIES_FILE
            echo "GIT_COMMIT=$GIT_COMMIT" >> $ARTIFACTS_PATH/$PROPERTIES_FILE
            # Change  write access permission to allow subsequent task(s) to update if needed
            chmod go+rw $ARTIFACTS_PATH/$PROPERTIES_FILE
            echo "$PROPERTIES_FILE content:"
            cat $ARTIFACTS_PATH/$PROPERTIES_FILE
          fi

          if [ "$JSON_FILE_GIT_CREDENTIALS" ]; then
            # Ensure directory is there
            mkdir -p $ARTIFACTS_PATH/$(dirname "$JSON_FILE_GIT_CREDENTIALS")
            # Create a JSON file as output of this step to store the git credentials for future use
            echo "{" > "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
            echo "\"GIT_REPOSITORY\":\"${REPOSITORY}\"," >> "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
            echo "\"GIT_AUTH_USER\":\"${GIT_AUTH_USER}\"," >> "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
            echo "\"GIT_TOKEN\":\"${GIT_TOKEN}\"" >> "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
            echo "}" >> "${ARTIFACTS_PATH}/${JSON_FILE_GIT_CREDENTIALS}"
          fi


          # Record task results

          echo -n "${REPOSITORY}" > $(results.git-repository.path)

          echo -n "${BRANCH}" > $(results.git-branch.path)

          echo -n "${GIT_COMMIT}" > $(results.git-commit.path)

          echo -n "${GIT_AUTH_USER}" > $(results.git-user.path)
        volumeMounts:
          - mountPath: /steps
            name: steps-volume
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: git-set-commit-status
    description: This task will set CI status on the commit
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          Name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: ibmcloud-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud
        default: apikey
      - name: git-access-token
        description: >
          (optional) token to access the git repository. If this token is
          provided, there will not be an attempt

          to use the git token obtained from the authorization flow when adding
          the git integration in the toolchain
        default: ''
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: repository
        description: |
          The git repository url
      - name: revision
        description: |
          (optional) Commit SHA to set the status for.
          If left empty, will attempt to read GIT_COMMIT from build-properties
        default: ''
      - name: description
        description: |
          A short description of the status.
      - name: context
        description: |
          A string label to differentiate this status from
          the status of other systems. ie: "continuous-integration/tekton"
        default: continuous-integration/tekton
      - name: state
        description: >
          The state of the status. Can be one of the following: `pending`,
          `running`, `success`, `failed`, `canceled`

          or a value meaningful for the target git repository

          - gitlab/hostedgit: `pending`, `running`, `success`, `failed`,
          `canceled`

          - github/integrated github: `pending`, `success`, `failure`, `error`

          - bitbucket: `SUCCESSFUL`, `FAILED`, `INPROGRESS`, `STOPPED`
        default: ''
      - name: state-var
        description: >
          Customized variable stored in build-properties to use as state if
          state params is empty.
        type: string
        default: ''
      - name: build-properties
        description: >
          file containing properties out of clone task (can be a filepath name
          relative to the workspace/volume)
        default: build.properties
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    workspaces:
      - name: artifacts
        description: >
          Workspace that may contain git repository information (ie
          build.properties).

          Should be marked as optional when Tekton will permit it
        mountPath: /artifacts
    stepTemplate:
      env:
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: fetch-git-information
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: REPOSITORY
            value: $(params.repository)
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.ibmcloud-apikey-secret-key)
                optional: true
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail


            if [ $PIPELINE_DEBUG == 1 ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi


            TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')

            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################

            if [[ "$REPOSITORY" != *.git ]]; then
              echo "Adding .git suffix to Repository URL"
              REPOSITORY="${REPOSITORY}.git"
            fi

            GIT_SERVICE_INSTANCE_ID=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .instance_id' /cd-config/toolchain.json)
            if [ -z "$GIT_SERVICE_INSTANCE_ID" ]; then
              echo "No Git integration (repository url: $REPOSITORY) found in the toolchain"
              exit 1
            fi

            GIT_SERVICE_TYPE=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .service_id' /cd-config/toolchain.json)
            if [ "$GIT_SERVICE_TYPE" == "github" ]; then
              GIT_AUTH_USER="x-oauth-basic"
            elif [ "$GIT_SERVICE_TYPE" == "githubpublic" ]; then
              GIT_AUTH_USER="x-oauth-basic"
            elif [ "$GIT_SERVICE_TYPE" == "hostedgit" ]; then
              GIT_AUTH_USER="oauth2"
            elif [ "$GIT_SERVICE_TYPE" == "gitlab" ]; then
              GIT_AUTH_USER="oauth2"
            elif [ "$GIT_SERVICE_TYPE" == "bitbucketgit" ]; then
              GIT_AUTH_USER="x-token-auth"
            else
              GIT_AUTH_USER="x-token-auth"
            fi;

            GIT_TOKEN="$(params.git-access-token)"

            if [ -z "$GIT_TOKEN" ]; then
              echo "Fetching token for $REPOSITORY"
              ibmcloud config --check-version false
              ibmcloud login -a $(params.ibmcloud-api) -r $TOOLCHAIN_REGION --apikey $API_KEY
              if [ "$(params.resource-group)" ]; then
                ibmcloud target -g "$(params.resource-group)"
              fi
              TOKEN=$(ibmcloud iam oauth-tokens --output JSON | jq -r '.iam_token')
              GIT_TOKEN_URL=$(jq -r --arg git_repo "$REPOSITORY" \
                '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.token_url' \
                /cd-config/toolchain.json)

              # GIT_TOKEN_URL is something like
              # https://otc-github-consolidated-broker.us-south.devops.cloud.ibm.com/github/token?git_id=github
              # as there is already an url param git_id, just put the additional ones using &

              GIT_BROKER_URL="${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
              echo "Doing cURL to ${GIT_BROKER_URL}"

              curl -s -o /steps/github_token_result.json -X GET -H "Accept: application/json" \
                -H "Authorization: $TOKEN" "$GIT_BROKER_URL"
              if jq -e '.access_token' /steps/github_token_result.json > /dev/null 2>&1; then
                GIT_TOKEN=$(jq -r '.access_token' /steps/github_token_result.json)
                echo "Access token found for the Git integration (repository url: $REPOSITORY)"
              else
                echo "No access token found for the Git integration (repository url: $REPOSITORY)"
                cat /steps/github_token_result.json
                exit 1
              fi
            else
              echo "Using git Access Token provided"
            fi


            GIT_API_ROOT_URL=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.api_root_url' \
              /cd-config/toolchain.json)
            GIT_OWNER_ID=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.owner_id' /cd-config/toolchain.json)
            GIT_REPO_NAME=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.repo_name' /cd-config/toolchain.json)
            GIT_ID=$(jq -r --arg git_repo "$REPOSITORY" \
              '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.git_id' /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')


            echo "GIT_REPOSITORY=$REPOSITORY" > /steps/next-step-env.properties

            echo "GIT_AUTH_USER=$GIT_AUTH_USER" >>
            /steps/next-step-env.properties

            echo "GIT_TOKEN=$GIT_TOKEN" >> /steps/next-step-env.properties

            echo "GIT_SERVICE_TYPE=$GIT_SERVICE_TYPE" >>
            /steps/next-step-env.properties

            echo "GIT_ID=$GIT_ID" >> /steps/next-step-env.properties

            echo "GIT_API_ROOT_URL=$GIT_API_ROOT_URL" >>
            /steps/next-step-env.properties

            echo "GIT_OWNER_ID=$GIT_OWNER_ID" >> /steps/next-step-env.properties

            echo "GIT_REPO_NAME=$GIT_REPO_NAME" >>
            /steps/next-step-env.properties

            echo "TOOLCHAIN_REGION=$TOOLCHAIN_REGION" >>
            /steps/next-step-env.properties


            if [ $PIPELINE_DEBUG == 1 ]; then
              cat /steps/next-step-env.properties
            fi
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
      - name: set-status
        image: 'registry.access.redhat.com/ubi8/ubi:8.1'
        env:
          - name: PIPELINE_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-id'']'
          - name: PIPELINE_RUN_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
        script: >
          #!/usr/libexec/platform-python

          import json

          import os

          import sys

          import urllib.request

          import urllib.parse


          # extract the previouly properties found in previous step

          previous_step={}

          if os.environ["PIPELINE_DEBUG"] == "1":
            print("previous step properties:")
          f = open("/steps/next-step-env.properties", "r")

          for x in f:
            if os.environ["PIPELINE_DEBUG"] == "1":
              print(x)
            prop = x.split("=", 1)
            previous_step[prop[0]] = prop[1].strip()
          f.close()


          # extract the build properties in their own structure

          build={}

          if os.path.exists("/artifacts/$(params.build-properties)"):
            if os.environ["PIPELINE_DEBUG"] == "1":
              print("$(params.build-properties):")
            f = open("/artifacts/$(params.build-properties)", "r")
            for x in f:
                if os.environ["PIPELINE_DEBUG"] == "1":
                  print(x)
                prop = x.split("=", 1)
                build[prop[0]] = prop[1].strip()
            f.close()

          # find the state

          state = "$(params.state)"

          if "$(params.state-var)" != "":
            print("Looking for state in $(params.build-properties)")
            state = build["$(params.state-var)"]

          # Make the state value consistent to the git flavor

          # Generic state values are: pending, running, success, failed,
          canceled

          # Define mapping from generic to git flavor to put the appropriate
          value for git target

          # Allowed Github state values: pending, success, failure, error

          state_mapping_generic_to_github = {
            "failed": "failure",
            "canceled": "error",
            "running": "pending"
          }

          # Gitlab: pending, running, success, failed, canceled

          # no mapping for gitlab as generic state value are identical

          # Allowed Bitbucket state values: SUCCESSFUL, FAILED, INPROGRESS,
          STOPPED

          state_mapping_generic_to_bitbucket = {
            "pending": "INPROGRESS",
            "running": "INPROGRESS",
            "success": "SUCCESSFUL",
            "failed": "FAILED",
            "canceled": "STOPPED"
          }


          # find the commit to set status on

          revision = "$(params.revision)"

          if revision == "":
            revision = build["GIT_COMMIT"]

          description="$(params.description)"


          context="$(params.context)"


          # compute the target url of this pipeline run

          target_url = ("https://cloud.ibm.com/devops/pipelines/tekton/" +
          os.environ["PIPELINE_ID"] +
            "/runs/" + os.environ["PIPELINE_RUN_ID"] + "?env_id=ibm:yp:" + previous_step["TOOLCHAIN_REGION"])

          # Create the request object according to the Git Falvor API

          if previous_step["GIT_ID"] == "gitlab" or previous_step["GIT_ID"] ==
          "hostedgit" :
            status_url = (previous_step["GIT_API_ROOT_URL"]
              + "/v4/projects/" + previous_step["GIT_OWNER_ID"] + "%2F" + previous_step["GIT_REPO_NAME"]
              + "/statuses/" + revision)
            params = {
              "state": state,
              "description": description,
              "context": context,
              "target_url": target_url
            }
            url_query_params = urllib.parse.urlencode(params)
            req = urllib.request.Request(
              status_url + "?" + url_query_params,
              data=None,
              headers={
                  "Authorization": "Bearer " + previous_step["GIT_TOKEN"]
              },
              method="POST"
            )
          elif previous_step["GIT_ID"] == "bitbucketgit":
            status_url = (previous_step["GIT_API_ROOT_URL"]
              + "/2.0/repositories/" + previous_step["GIT_OWNER_ID"] + "/" + previous_step["GIT_REPO_NAME"]
              + "/commit/" + revision + "/statuses/build")

            if state in state_mapping_generic_to_bitbucket:
              bitbucket_state = state_mapping_generic_to_bitbucket[state]
            else:
              # No mapping found - use the state value provided
              bitbucket_state = state
            print("State value '" + state + "' mapped to bitbucket state '" + bitbucket_state + "'")

            data = {
              "key": os.environ["PIPELINE_ID"],
              "url": target_url,
              "state": bitbucket_state,
              "name": context,
              "description": description
            }
            req = urllib.request.Request(
              status_url,
              data=json.dumps(data).encode('utf8'),
              headers={
                  "content-type": "application/json",
                  "Authorization": "Bearer " + previous_step["GIT_TOKEN"]
              },
              method="POST"
            )
          else:
            # Default to github
            if previous_step["GIT_ID"] == "integrated":
              api_prefix="/v3"
            else:
              api_prefix=""

            if state in state_mapping_generic_to_github:
              github_state = state_mapping_generic_to_github[state]
            else:
              # No mapping found - use the state value provided
              github_state = state

            print("State value '" + state + "' mapped to github state '" + github_state + "'")

            status_url = (previous_step["GIT_API_ROOT_URL"] + api_prefix
              + "/repos/" + previous_step["GIT_OWNER_ID"] + "/" + previous_step["GIT_REPO_NAME"]
              + "/statuses/" + revision)
            data = {
              "state": github_state,
              "target_url": target_url,
              "description": description,
              "context": context
            }
            req = urllib.request.Request(
              status_url,
              data=json.dumps(data).encode('utf8'),
              headers={
                  "content-type": "application/json",
                  "Authorization": "Bearer " + previous_step["GIT_TOKEN"]
              },
              method="POST"
            )

          req.add_header("User-Agent", "TektonCD, the peaceful cat")


          with urllib.request.urlopen(req) as resp:
            if not str(resp.status).startswith("2"):
              print("Error: %d" % (resp.status))
              print(resp.read())
              sys.exit(1)
            else:
              print(previous_step["GIT_ID"] + " commit status '" + state + "' has been set on "
                + previous_step["GIT_REPOSITORY"] + "#" + revision)
              if os.environ["PIPELINE_DEBUG"] == "1":
                print("Status: %d" % (resp.status))
                print(resp.read())
              sys.exit(0)
        volumeMounts:
          - mountPath: /steps
            name: steps-volume
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: check-registry-scripts
  data:
    parse_image_url.sh: >
      ##########################################################################

      # Parse the image url to find information (region, namespace, image name
      and eventually tag)

      # as url of Image PipelineResource is the complete path to the image,
      including the registry

      # and the image tag -
      https://github.com/tektoncd/pipeline/blob/v0.10.1/docs/resources.md#image-resource

      # Environment variables:

      # - IMAGE_RESOURCE_URL (input) : can include a tag

      # - IMAGE_URL (output)

      # - REGISTRY_REGION (output)

      # - REGISTRY_NAMESPACE (output)

      # - IMAGE_NAME (output)

      # - IMAGE_TAG (output)

      ##########################################################################

      IMAGE_URL=$(echo $IMAGE_RESOURCE_URL |  awk -F: '{print $1}')

      IMAGE_TAG=$(echo $IMAGE_RESOURCE_URL |  awk -F: '{print $2}')

      REGISTRY_URL=$(echo $IMAGE_RESOURCE_URL |  awk -F/ '{print $1}')

      REGISTRY_NAMESPACE=$(echo $IMAGE_RESOURCE_URL |  awk -F/ '{print $2}')

      # Image name is remaining part after the repository and namespace and can
      contains /

      IMAGE_NAME=$(echo $IMAGE_URL |  awk -F/ '{a=match($0, $3); print
      substr($0,a)}')


      # Find the ibmcloud container registry region

      #
      https://cloud.ibm.com/docs/services/Registry?topic=registry-registry_overview#registry_regions_local

      if [[ $REGISTRY_URL =~ ^registry\.[a-z]*.bluemix.net$ ]]; then
        # deprecated domain name
        REGISTRY_REGION=$(echo $REGISTRY_URL | awk -F. '{print $2}')
        if [ "$REGISTRY_REGION" == "ng" ]; then
          REGISTRY_REGION="us-south"
        fi
      else
        export REGISTRY_REGION=$(echo $REGISTRY_URL | awk -F. '{print $1}')
        if [ "$REGISTRY_REGION" == "jp" ]; then
          REGISTRY_REGION="ap-north"
        elif [ "$REGISTRY_REGION" == "au" ]; then
          REGISTRY_REGION="ap-south"
        elif [ "$REGISTRY_REGION" == "de" ]; then
          REGISTRY_REGION="eu-central"
        elif [ "$REGISTRY_REGION" == "uk" ]; then
          REGISTRY_REGION="uk-south"
        elif [ "$REGISTRY_REGION" == "us" ]; then
          REGISTRY_REGION="us-south"
        elif [ "$REGISTRY_REGION" == "stg" ]; then
          REGISTRY_REGION="us-south"
        else
          echo "No IBM Cloud Container Registry region found for the registry url $REGISTRY_URL"
          exit 1
        fi
      fi
    check_registry.sh: >
      ##########################################################################

      # Environment variables:

      # - IBMCLOUD_API (input)

      # - IBMCLOUD_RESOURCE_GROUP (input)

      # - REGISTRY_REGION (input)

      # - REGISTRY_NAMESPACE (input)

      # - REGISTRY_CREATE_NAMESPACE (input)

      ##########################################################################


      TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)

      TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json | awk -F:
      '{print $3}')


      # ibmcloud login

      ibmcloud config --check-version false

      ibmcloud login -a $IBMCLOUD_API -r $TOOLCHAIN_REGION --apikey $API_KEY

      if [ "$IBMCLOUD_RESOURCE_GROUP" ]; then
        ibmcloud target -g "$IBMCLOUD_RESOURCE_GROUP"
      fi


      # Log container registry to the appropriate region

      if ibmcloud cr region-set $REGISTRY_REGION > /dev/null 2>&1; then
        echo "ibmcloud container registry region set to $REGISTRY_REGION"
      else
        # the registry region specified is not supported - fallback on
        # using ibmcloud target -r command to rely on region affinity
        # for container registry region - for instance us-east does not have
        # a container-registry service, it is defered to us-south
        ibmcloud target -r $REGISTRY_REGION
      fi

      ibmcloud cr info


      # Check available quota on CR

      if ibmcloud cr quota | grep 'Your account has exceeded its storage
      quota.'; then
        echo "Your account has exceeded its storage quota. You can check your images at https://cloud.ibm.com/kubernetes/registry/main/images"
        exit 1
      fi


      # Create the namespace if needed to ensure the push will be can be
      successfull

      echo "Checking registry namespace: ${REGISTRY_NAMESPACE}"

      NS=$( ibmcloud cr namespaces | grep ${REGISTRY_NAMESPACE} ||: )

      if [ -z "${NS}" ]; then
          echo "Registry namespace ${REGISTRY_NAMESPACE} not found"
          if [ "$REGISTRY_CREATE_NAMESPACE" == "true" ] ; then
            ibmcloud cr namespace-add ${REGISTRY_NAMESPACE}
            echo "Registry namespace ${REGISTRY_NAMESPACE} created."
          else
            echo "Skipping creation of registry namespace ${REGISTRY_NAMESPACE}."
          fi
      else
          echo "Registry namespace ${REGISTRY_NAMESPACE} found."
      fi
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: icr-check-va-scan
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          Name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: container-registry-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud container registry
        default: apikey
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: image-url
        description: >-
          url of the image to VA scan - required if no image pipeline resource
          provided to this task
        default: ''
      - name: image-digest
        description: >-
          SHA id of the image to VA scan - required if no image pipeline
          resource provided to this task
        default: ''
      - name: image-properties-file
        description: file containing properties of the image to be scanned
        default: build.properties
      - name: max-iteration
        description: maximum number of iterations allowed while loop to check for va report
        default: '30'
      - name: sleep-time
        description: >-
          sleep time (in seconds) between invocation of ibmcloud cr va in the
          loop
        default: '10'
      - name: scan-report-file
        description: >-
          filename for the scan report (json format) of the given image. It will
          be copied in the workspace
        default: ''
      - name: fail-on-scanned-issues
        description: >
          flag (`true` | `false`) to indicate if the task should fail or
          continue

          if issues are found in the image scan result
        default: 'true'
      - name: pipeline-debug
        default: '0'
    results:
      - name: scan-report-file
        description: the filename if the scan report for the image stored in the workspace
      - name: scan-status
        description: >
          the status from Vulnerability Advisor - possible values: OK, WARN,
          FAIL, UNSUPPORTED, INCOMPLETE, UNSCANNED
    workspaces:
      - name: artifacts
        description: >
          Workspace that may contain image information and will have the va
          report from the VA scan

          after this task execution.
        mountPath: /artifacts
    resources:
      inputs:
        - name: image
          type: image
          description: (Optional) The image that has to be VA scanned
          optional: true
    steps:
      - name: run-vulnerability-advisor-scan
        image: 'ibmcom/pipeline-base-image:2.9'
        workingDir: /artifacts
        env:
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.container-registry-apikey-secret-key)
          - name: PIPELINE_DEBUG
            value: $(params.pipeline-debug)
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail


            if [ $PIPELINE_DEBUG == 1 ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi


            TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')

            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################


            if [ "$(resources.inputs.image.url)" == "" ]; then
              INPUT_IMAGE_URL=$(echo "$(params.image-url)" |  awk -F: '{print $1}')
            else
              INPUT_IMAGE_URL=$(echo "$(resources.inputs.image.url)" |  awk -F: '{print $1}')
            fi


            # Parse the image input to find information (region, namespace,
            image name, tag & digest/sha)

            INPUT_REGISTRY_URL=$(echo $INPUT_IMAGE_URL |  awk -F/ '{print $1}')

            INPUT_REGISTRY_NAMESPACE=$(echo $INPUT_IMAGE_URL |  awk -F/ '{print
            $2}')

            INPUT_IMAGE_NAME=$(echo $INPUT_IMAGE_URL |  awk -F/ '{print $3}')

            INPUT_IMAGE_TAG=$(echo $INPUT_IMAGE_URL |  awk -F: '{print $2}')


            if [ "$(resources.inputs.image.digest)" == "" ]; then
              INPUT_IMAGE_DIGEST=$(params.image-digest)
            else
              INPUT_IMAGE_DIGEST=$(resources.inputs.image.digest)
            fi


            # Find the ibmcloud container registry region

            #
            https://cloud.ibm.com/docs/services/Registry?topic=registry-registry_overview#registry_regions_local

            if [[ $INPUT_REGISTRY_URL =~ ^registry\.[a-z]*.bluemix.net$ ]]; then
              # deprecated domain name
              REGISTRY_REGION=$(echo $INPUT_REGISTRY_URL | awk -F. '{print $2}')
              if [ "$REGISTRY_REGION" == "ng" ]; then
                REGISTRY_REGION="us-south"
              fi
            else
              export REGISTRY_REGION=$(echo $INPUT_REGISTRY_URL | awk -F. '{print $1}')
              if [ "$REGISTRY_REGION" == "jp" ]; then
                REGISTRY_REGION="ap-north"
              elif [ "$REGISTRY_REGION" == "au" ]; then
                REGISTRY_REGION="ap-south"
              elif [ "$REGISTRY_REGION" == "de" ]; then
                REGISTRY_REGION="eu-central"
              elif [ "$REGISTRY_REGION" == "uk" ]; then
                REGISTRY_REGION="uk-south"
              elif [ "$REGISTRY_REGION" == "us" ]; then
                REGISTRY_REGION="us-south"
              elif [ "$REGISTRY_REGION" == "stg" ]; then
                REGISTRY_REGION="us-south"
              elif [ "$REGISTRY_REGION" == "fr2" ]; then
                REGISTRY_REGION="eu-fr2"
              else
                echo "No IBM Cloud Container Registry region found for the registry url $INPUT_REGISTRY_URL"
                exit 1
              fi
            fi


            # ibmcloud login

            ibmcloud config --check-version false

            ibmcloud login -a $(params.ibmcloud-api) -r $TOOLCHAIN_REGION
            --apikey $API_KEY

            if [ "$(params.resource-group)" ]; then
              ibmcloud target -g "$(params.resource-group)"
            fi


            # Log container registry to the appropriate region

            if ibmcloud cr region-set $REGISTRY_REGION > /dev/null 2>&1; then
              echo "ibmcloud container registry region set to $REGISTRY_REGION"
            else
              # the registry region specified is not supported - fallback on
              # using ibmcloud target -r command to rely on region affinity
              # for container registry region - for instance us-east does not have
              # a container-registry service, it is defered to us-south
              ibmcloud target -r $REGISTRY_REGION
            fi

            ibmcloud cr info


            # Because of https://github.com/tektoncd/pipeline/issues/216 the
            image digest for input is probably empty

            # If image digest is empty, then use the imageProperties file to
            obtain the information

            if [ -z "$INPUT_IMAGE_DIGEST" ]; then
              if [ -z "$(params.image-properties-file)" ]; then
                echo "No digest found - use only the image url"
                PIPELINE_IMAGE_URL="$INPUT_IMAGE_URL"
              else
                # Look for the digest in the image-properties-file
                echo "Search for digest in the $(params.image-properties-file)"
                source $(params.image-properties-file)
                PIPELINE_IMAGE_URL="$INPUT_IMAGE_URL@$IMAGE_MANIFEST_SHA"
              fi
            else
              PIPELINE_IMAGE_URL="$INPUT_IMAGE_URL@$INPUT_IMAGE_DIGEST"
            fi


            # inspect the image to ensure it exists

            echo -e "Details for image: ${PIPELINE_IMAGE_URL}"

            ibmcloud cr image-inspect ${PIPELINE_IMAGE_URL}


            # Loop until the scan has been performed

            echo -e "Checking vulnerabilities in image: ${PIPELINE_IMAGE_URL}"

            for ITER in {1..$(params.max-iteration)}

            do
              set +e
              STATUS=""
              ibmcloud cr va -o json ${PIPELINE_IMAGE_URL} > /steps/vareport.json
              # ibmcloud cr va returns a non valid json output if image not yet scanned
              if jq -r -e '.[0].status' /steps/vareport.json > /dev/null 2>&1; then
                STATUS=$( jq -r '.[0].status' /steps/vareport.json)
              fi
              if [ -z "$STATUS" ]; then
                STATUS="UNSCANNED"
                cat /steps/vareport.json
              fi
              set -e
              echo "VA scan status is ${STATUS}"
              # Possible status from Vulnerability Advisor: OK, WARN, FAIL, UNSUPPORTED, INCOMPLETE, UNSCANNED
              # cf https://cloud.ibm.com/apidocs/container-registry/va#get-the-vulnerability-assessment-for-the-list-of-r
              if [[ "${STATUS}" != "INCOMPLETE" && "${STATUS}" != "UNSCANNED" ]]; then
                # status is one of the terminated scan action - break the loop
                break
              fi
              echo -e "${ITER} STATUS ${STATUS} : A vulnerability report was not found for the specified image."
              echo "Either the image doesn't exist or the scan hasn't completed yet. "
              echo "Waiting $(params.sleep-time)s for scan to complete..."
              sleep $(params.sleep-time)
            done

            set +e

            echo "Showing extended vulnerability assessment report for
            ${PIPELINE_IMAGE_URL}"

            ibmcloud cr va -e ${PIPELINE_IMAGE_URL} || true

            set -e

            if [ "$(params.scan-report-file)" ]; then
              echo -n "Copy Vulnerability Advisor scan report (JSON format) to "
              echo "$(workspaces.artifacts.path)/$(params.scan-report-file)"
              cp /steps/vareport.json $(workspaces.artifacts.path)/$(params.scan-report-file)
            fi


            # Record task results

            echo -n "$(params.scan-report-file)" >
            $(results.scan-report-file.path)

            echo -n "${STATUS}" > $(results.scan-status.path)


            if [[ "${STATUS}" == "OK" ]] || [[ "${STATUS}" == "UNSUPPORTED" ]]
            || [[ "${STATUS}" == "WARN" ]]; then
              echo "The vulnerability scan status is ${STATUS}"
            else
              echo -n "ERROR: The vulnerability scan was not successful (status being ${STATUS}), "
              echo "check the OUTPUT of the command and try again."
              if [ "$(params.fail-on-scanned-issues)" == "true" ]; then
                exit 1;
              fi
            fi
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
    volumes:
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
      - name: steps-volume
        emptyDir: {}
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: icr-containerize
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          Name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: container-registry-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud container registry
        default: apikey
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: image-url
        description: >
          url of the image to build

          required if no image pipeline resource provided or no registry region,
          namespace and image name parameters

          are provided to this task
        default: ''
      - name: registry-region
        description: >-
          container registry region id. required if no image-url or no image
          pipeline resources provided
        default: ''
      - name: registry-namespace
        description: >-
          container registry namespace. required if no image-url or no image
          pipeline resources provided
        default: ''
      - name: registry-create-namespace
        description: create container registry namespace if it doesn't already exists
        default: 'true'
      - name: image-name
        description: >-
          image name. required if no image-url or no image pipeline resources
          provided
        default: ''
      - name: path-to-context
        default: .
      - name: path-to-dockerfile
        default: .
      - name: dockerfile
        description: The name of the Dockerfile
        default: Dockerfile
      - name: build-args
        description: >-
          build argument list in the format 'KEY=VALUE' with a key-value pair
          per line.
        default: ''
      - name: buildkit-image
        description: The name of the BuildKit image
        default: 'moby/buildkit:v0.7.2'
      - name: additional-tags
        description: comma-separated list of additional-tags
        default: ''
      - name: additional-tags-script
        description: Shell script that allows to add tags for the image to be build.
        default: ''
      - name: properties-file
        description: file containing properties out of containerize task
        default: build.properties
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    results:
      - name: image-repository
        description: the repository for the built image
      - name: image-tags
        description: the tags for the built image
      - name: image-digest
        description: the image digest (sha-256 hash) for the built image
    workspaces:
      - name: source
        description: >-
          A workspace containing the source (Dockerfile, Docker context) to
          create the image
        mountPath: /artifacts
    resources:
      outputs:
        - name: built-image
          type: image
          description: (Optional) The image to build
          optional: true
    stepTemplate:
      env:
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: check-registry
        image: 'ibmcom/pipeline-base-image:2.9'
        workingDir: /steps
        env:
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.container-registry-apikey-secret-key)
          - name: IBMCLOUD_API
            value: $(params.ibmcloud-api)
          - name: IBMCLOUD_RESOURCE_GROUP
            value: $(params.resource-group)
          - name: REGISTRY_CREATE_NAMESPACE
            value: $(params.registry-create-namespace)
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail


            if [ $PIPELINE_DEBUG == 1 ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi


            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################


            if [ "$(resources.outputs.built-image.url)" == "" ]; then
              export IMAGE_RESOURCE_URL="$(params.image-url)"
            else
              export IMAGE_RESOURCE_URL="$(resources.outputs.built-image.url)"
            fi


            if [ "$IMAGE_RESOURCE_URL" ]; then
              # Parse the image url to find registry information
              source /scripts/parse_image_url.sh
            else
              # export the expected environment variables based on the required registry parameters
              # if registry region is in the 'ibm:yp:<region>' just keep the region part
              export REGISTRY_REGION=$(echo "$(params.registry-region)" | awk -F ':' '{print $NF;}')

              if [ -z "$REGISTRY_REGION" ]; then
                echo "No registry region provided"
                exit 1
              fi
              export REGISTRY_NAMESPACE=$(params.registry-namespace)
              if [ -z "$REGISTRY_NAMESPACE" ]; then
                echo "No registry namespace provided"
                exit 1
              fi
            fi


            # Login to the container registry and ensure namespace is available

            source /scripts/check_registry.sh


            if [ -z "$IMAGE_RESOURCE_URL" ]; then
              export IMAGE_NAME=$(params.image-name)
              if [ -z "$IMAGE_NAME" ]; then
                echo "No image name provided"
                exit 1
              fi
              # export the expected environment variables now that the container registry is logged in
              export REGISTRY_URL=$(ibmcloud cr info | grep -m1 -i '^Container Registry' | awk '{print $3;}')
              export IMAGE_URL="${REGISTRY_URL}/${REGISTRY_NAMESPACE}/${IMAGE_NAME}"
            fi


            # create a dry-run k8s secret of type docker-registry to obtain

            # the content of a docker config.json file to access the target

            # ibmcloud container registry

            kubectl create secret --dry-run=true --output=json \
              docker-registry registry-dockerconfig-secret \
              --docker-server=${REGISTRY_URL} \
              --docker-password=${API_KEY} \
              --docker-username=iamapikey --docker-email=a@b.com | \
            jq -r '.data[".dockerconfigjson"]' | base64 -d > config.json


            echo "REGISTRY_URL=${REGISTRY_URL}" > next-step-env.properties

            echo "REGISTRY_NAMESPACE=${REGISTRY_NAMESPACE}" >>
            next-step-env.properties

            echo "REGISTRY_REGION=${REGISTRY_REGION}" >>
            next-step-env.properties

            echo "IMAGE_URL=${IMAGE_URL}" >> next-step-env.properties

            echo "IMAGE_TAG=${IMAGE_TAG}" >> next-step-env.properties

            echo "IMAGE_NAME=${IMAGE_NAME}" >> next-step-env.properties
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
          - mountPath: /scripts
            name: check-registry-scripts
      - name: build-image
        image: $(params.buildkit-image)
        workingDir: /artifacts
        env:
          - name: DOCKER_CONFIG
            value: /steps
          - name: PIPELINE_RUN_NAME
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.labels[''tekton.dev/pipelineRun'']'
          - name: PIPELINE_RUN_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
          - name: BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
          - name: PIPELINE_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-id'']'
          - name: TRIGGER_TYPE
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/trigger-type'']'
          - name: TRIGGER_NAME
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/trigger-name'']'
          - name: TRIGGERED_BY
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/triggered-by'']'
        securityContext:
          privileged: true
        command:
          - /bin/sh
          - '-c'
        args:
          - >
            if [ $PIPELINE_DEBUG == 1 ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi


            source /steps/next-step-env.properties

            export $(cut -d= -f1 /steps/next-step-env.properties)


            # Manage multiple tags for an image

            # Add dynamically computed tags

            printf "#!/bin/sh\n" > /steps/additionalTags.sh

            printf "%s " '$(params.additional-tags-script)' >>
            /steps/additionalTags.sh

            chmod +x /steps/additionalTags.sh


            # Send stdout to the tags list; don't touch stderr.

            /steps/additionalTags.sh > /steps/tags.lst


            # Add image pipeline resource

            if [ "${IMAGE_TAG}" ]; then
              echo "${IMAGE_TAG}" >> /steps/tags.lst
            fi

            # Add tags provided using task parameter

            if [ "$(params.additional-tags)" ];  then
              echo "$(params.additional-tags)" | sed 's/,/\n/g' >> /steps/tags.lst
            fi

            echo "#######################"

            echo "Image Tags:"

            cat /steps/tags.lst

            echo "#######################"

            IMAGE_REPOSITORY="$REGISTRY_URL/$REGISTRY_NAMESPACE/$IMAGE_NAME"

            # Add the full image url with tags - use # as separator in case
            IMAGE_NAME contains /

            sed -i "s#^#$IMAGE_REPOSITORY:#" /steps/tags.lst

            sort -u -o /steps/tags.lst /steps/tags.lst

            echo "Full Image URLs:"

            cat /steps/tags.lst

            echo "#######################"

            BUILDKIT_IMAGE_NAMES=$(tr -s '\r\n' ',' < /steps/tags.lst | sed -e
            's/,$/\n/')

            if [ -z "$BUILDKIT_IMAGE_NAMES" ]; then
              # Set default image name for buildkit to push
              BUILDKIT_IMAGE_NAMES="$REGISTRY_URL/$REGISTRY_NAMESPACE/$IMAGE_NAME"
            fi

            echo "Buildkit Image names: $BUILDKIT_IMAGE_NAMES"


            BUILD_ARG_LIST='$(params.build-args)'

            for buildArg in $BUILD_ARG_LIST; do
              BUILD_ARGS="${BUILD_ARGS} --opt build-arg:$buildArg "
            done


            buildctl --addr tcp://0.0.0.0:1234 build \
              --progress=plain \
              --frontend=dockerfile.v0 \
              --opt filename=$(params.dockerfile) \
              ${BUILD_ARGS} \
              --local context=$(workspaces.source.path)/$(params.path-to-context) \
              --local dockerfile=$(workspaces.source.path)/$(params.path-to-dockerfile) \
              --exporter=image --exporter-opt "name=$BUILDKIT_IMAGE_NAMES" --exporter-opt "push=true" \
              --export-cache type=inline \
              --import-cache type=registry,ref=$IMAGE_REPOSITORY 2>&1 | tee /steps/build.log

            # Using the deprecated --exporter option for now as the multiple
            name/tags using --output option

            # is not working as expected:
            https://github.com/moby/buildkit/issues/797#issuecomment-581346240

            # --output
            type=image,"name=$(params.image-url):1.0.0,$(params.image-url)",push=true


            # it is not possible to specify multiple exporters for now

            # --output
            type=oci,dest=/builder/home/image-outputs/built-image/output.tar \

            # It is possible to assign multiple tags to the image with latest
            version of buildkit-image

            # see https://github.com/moby/buildkit/issues/797
        volumeMounts:
          - mountPath: /steps
            name: steps-volume
      - name: process-build-log
        image: 'ibmcom/pipeline-base-image:2.9'
        workingDir: /steps
        env:
          - name: PROPERTIES_FILE
            value: $(params.properties-file)
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail


            if [ $PIPELINE_DEBUG == 1 ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi


            source /steps/next-step-env.properties

            export $(cut -d= -f1 /steps/next-step-env.properties)


            # buildctl/buildkit does not provide an index.json as part of the
            output

            # https://github.com/moby/buildkit/issues/1158 and
            https://github.com/moby/buildkit/issues/993

            # https://github.com/moby/buildkit/pull/1315

            # unfortunately, this is needed for Tekton Image Pipeline Resource

            #
            https://github.com/tektoncd/pipeline/blob/v0.7.0/docs/resources.md#image-resource

            # so workaround for now is to process the buildkit log to find the
            required information


            MANIFEST_SHA=$(grep -i 'exporting manifest' build.log | grep -i
            'done' | awk '{print $4}')

            CONFIG_SHA=$(grep -i 'exporting config' build.log | grep -i 'done' |
            awk '{print $4}')

            FULLY_QUALIFIED_IMAGE=$(grep -i 'pushing manifest' build.log | grep
            -i 'done' | awk '{print $5}')


            if [ "$(resources.outputs.built-image.url)" ]; then
              echo "Creating OCI image index - index.json - out of the build.log to reference image sha: $MANIFEST_SHA"
              # ibmcloud container-registry image manifest is: application/vnd.docker.distribution.manifest.v2+json
              echo "{}" | \
              jq --arg manifest_sha "$MANIFEST_SHA" \
                '{schemaVersion:2,manifests:[{"mediaType": "application/vnd.oci.image.manifest.v1+json", digest:$manifest_sha}]}' 2>&1 | \
                tee /workspace/output/built-image/index.json

              # Copy the index.json to the legacy location - v0.7.0 - for such imageoutput
              mkdir -p /builder/home/image-outputs/built-image
              cp /workspace/output/built-image/index.json /builder/home/image-outputs/built-image
            fi


            # Because of https://github.com/tektoncd/pipeline/issues/216

            # the image digest for input is/will always empty

            # there was an alternative/workaround but it is updating using a
            specific account

            # and using a kubectl command to update the resources

            # see https://github.com/nlewo/poc-tekton#deploy-tasks

            #
            https://raw.githubusercontent.com/tektoncd/catalog/0b48da8e336a4214aff46af242658dc056199b1c/update-image-digests/image-digest-updater.yaml

            #
            https://raw.githubusercontent.com/tektoncd/catalog/0b48da8e336a4214aff46af242658dc056199b1c/update-image-digests/update-image-digests.yaml

            # Here the workaround will be to add registry and image information
            in an output properties file

            IMAGE_TAGS=$(grep -i 'pushing manifest' /steps/build.log | grep -i
            'done' | awk '{print $5}' | \
              awk -F: '{print $2}' | tr -s '\r\n' ',' | sed -e 's/,$/\n/')
            if [ "$PROPERTIES_FILE" ]; then
              mkdir -p $(workspaces.source.path)/$(dirname "$PROPERTIES_FILE")
              echo "REGISTRY_URL=${REGISTRY_URL}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "REGISTRY_NAMESPACE=${REGISTRY_NAMESPACE}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "REGISTRY_REGION=${REGISTRY_REGION}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "IMAGE_NAME=${IMAGE_NAME}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "IMAGE_TAGS=${IMAGE_TAGS}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "IMAGE_MANIFEST_SHA=${MANIFEST_SHA}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "$PROPERTIES_FILE content:"
              cat $(workspaces.source.path)/$PROPERTIES_FILE
              echo ""
            fi


            # Record task results

            echo -n "${IMAGE_URL}" > $(results.image-repository.path)

            echo -n "${IMAGE_TAGS}" > $(results.image-tags.path)

            echo -n "${MANIFEST_SHA}" > $(results.image-digest.path)
        volumeMounts:
          - mountPath: /steps
            name: steps-volume
    sidecars:
      - image: $(params.buildkit-image)
        name: server
        securityContext:
          privileged: true
        command:
          - sh
          - '-c'
        args:
          - >-
            if [[ $(df -PT /var/lib/buildkit | awk 'NR==2 {print $2}') ==
            virtiofs ]]; then apk add e2fsprogs && truncate -s 20G /tmp/disk.img
            && mkfs.ext4 /tmp/disk.img && mount /tmp/disk.img /var/lib/buildkit;
            fi && buildkitd --addr tcp://0.0.0.0:1234;
        readinessProbe:
          initialDelaySeconds: 2
          periodSeconds: 1
          exec:
            command:
              - buildctl
              - '--addr'
              - 'tcp://0.0.0.0:1234'
              - debug
              - workers
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
      - name: check-registry-scripts
        configMap:
          name: check-registry-scripts
          items:
            - key: check_registry.sh
              path: check_registry.sh
            - key: parse_image_url.sh
              path: parse_image_url.sh
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: icr-cr-build
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          Name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: container-registry-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud container registry
        default: apikey
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: image-url
        description: >
          url of the image to build

          required if no image pipeline resource provided or no registry region,
          namespace and image name parameters

          are provided to this task
        default: ''
      - name: registry-region
        description: >-
          container registry region id. required if no image-url or no image
          pipeline resources provided
        default: ''
      - name: registry-namespace
        description: >-
          container registry namespace. required if no image-url or no image
          pipeline resources provided
        default: ''
      - name: registry-create-namespace
        description: create container registry namespace if it doesn't already exists
        default: 'true'
      - name: image-name
        description: >-
          image name. required if no image-url or no image pipeline resources
          provided
        default: ''
      - name: path-to-context
        default: .
      - name: path-to-dockerfile
        default: .
      - name: dockerfile
        description: The name of the Dockerfile
        default: Dockerfile
      - name: build-args
        description: >-
          build argument list in the format 'KEY=VALUE' with a key-value pair
          per line.
        default: ''
      - name: additional-tags
        description: comma-separated list of additional-tags
        default: ''
      - name: additional-tags-script
        description: Shell script that allows to add tags for the image to be build.
        default: ''
      - name: properties-file
        description: file containing properties out of containerize task
        default: build.properties
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    results:
      - name: image-repository
        description: the repository for the built image
      - name: image-tags
        description: the tags for the built image
      - name: image-digest
        description: the image digest (sha-256 hash) for the built image
    workspaces:
      - name: source
        description: >-
          A workspace containing the source (Dockerfile, Docker context) to
          create the image
        mountPath: /artifacts
    resources:
      outputs:
        - name: built-image
          type: image
          description: (Optional) The image to build
          optional: true
    steps:
      - name: check-registry-and-build-image
        image: 'ibmcom/pipeline-base-image:2.7'
        workingDir: /artifacts
        env:
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.container-registry-apikey-secret-key)
          - name: IBMCLOUD_API
            value: $(params.ibmcloud-api)
          - name: IBMCLOUD_RESOURCE_GROUP
            value: $(params.resource-group)
          - name: PROPERTIES_FILE
            value: $(params.properties-file)
          - name: REGISTRY_CREATE_NAMESPACE
            value: $(params.registry-create-namespace)
          - name: PIPELINE_DEBUG
            value: $(params.pipeline-debug)
          - name: PIPELINE_RUN_NAME
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.labels[''tekton.dev/pipelineRun'']'
          - name: PIPELINE_RUN_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
          - name: BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
          - name: PIPELINE_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-id'']'
          - name: TRIGGER_TYPE
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/trigger-type'']'
          - name: TRIGGER_NAME
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/trigger-name'']'
          - name: TRIGGERED_BY
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/triggered-by'']'
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail


            if [ $PIPELINE_DEBUG == 1 ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi


            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################


            if [ "$(resources.outputs.built-image.url)" == "" ]; then
              export IMAGE_RESOURCE_URL="$(params.image-url)"
            else
              export IMAGE_RESOURCE_URL="$(resources.outputs.built-image.url)"
            fi


            if [ "$IMAGE_RESOURCE_URL" ]; then
              # Parse the image url to find registry information
              source /scripts/parse_image_url.sh
            else
              # export the expected environment variables based on the required registry parameters
              # if registry region is in the 'ibm:yp:<region>' just keep the region part
              export REGISTRY_REGION=$(echo "$(params.registry-region)" | awk -F ':' '{print $NF;}')

              if [ -z "$REGISTRY_REGION" ]; then
                echo "No registry region provided"
                exit 1
              fi
              export REGISTRY_NAMESPACE=$(params.registry-namespace)
              if [ -z "$REGISTRY_NAMESPACE" ]; then
                echo "No registry namespace provided"
                exit 1
              fi
            fi


            # Login to the container registry and ensure namespace is available

            source /scripts/check_registry.sh


            if [ -z "$IMAGE_RESOURCE_URL" ]; then
              export IMAGE_NAME=$(params.image-name)
              if [ -z "$IMAGE_NAME" ]; then
                echo "No image name provided"
                exit 1
              fi
              # export the expected environment variables now that the container registry is logged in
              export REGISTRY_URL=$(ibmcloud cr info | grep -m1 -i '^Container Registry' | awk '{print $3;}')
              export IMAGE_URL="${REGISTRY_URL}/${REGISTRY_NAMESPACE}/${IMAGE_NAME}"
            fi


            # Manage multiple tags for an image

            # Add dynamically computed tags

            printf "#!/bin/bash\n" > /steps/additionalTags.sh

            printf "%s " '$(params.additional-tags-script)' >>
            /steps/additionalTags.sh

            chmod +x /steps/additionalTags.sh


            # Send stdout to the tags list; don't touch stderr.

            /steps/additionalTags.sh >/steps/tags.lst


            # Add image pipeline resource

            if [ "${IMAGE_TAG}" ]; then
              echo "${IMAGE_TAG}" >> /steps/tags.lst
            fi

            # Add tags provided using task parameter

            if [ "$(params.additional-tags)" ];  then
              echo "$(params.additional-tags)" | sed 's/,/\n/g' >> /steps/tags.lst
            fi

            echo "#######################"

            echo "Image Tags:"

            cat /steps/tags.lst

            echo "#######################"

            # Add the full image url with tags - use # as separator in case
            IMAGE_NAME contains /

            sed -i "s#^#$REGISTRY_URL/$REGISTRY_NAMESPACE/$IMAGE_NAME:#"
            /steps/tags.lst

            sort -u -o /steps/tags.lst /steps/tags.lst

            echo "#######################"


            if [ -s /steps/tags.lst ]; then
              echo "Image tags:"
              cat /steps/tags.lst
            else
              # Force a minimal tag for the image build
              echo "$REGISTRY_URL/$REGISTRY_NAMESPACE/$IMAGE_NAME:latest" > /steps/tags.lst
              echo "Define a minimal image tag: $REGISTRY_URL/$REGISTRY_NAMESPACE/$IMAGE_NAME:latest"
            fi


            BUILD_ARG_LIST='$(params.build-args)'

            for buildArg in $BUILD_ARG_LIST; do
              BUILD_ARGS="${BUILD_ARGS} --build-arg $buildArg "
            done


            # Build the image using ibmcloud cr build for the first tag in the
            file

            ibmcloud cr build \
              ${BUILD_ARGS} \
              --file $(params.path-to-dockerfile)/$(params.dockerfile) \
              --tag $(head --lines=1 /steps/tags.lst) \
              $(params.path-to-context)

            # Create remaining tags for the image

            for tag in $(tail --lines=+2 /steps/tags.lst)

            do
              ibmcloud cr image-tag $(head --lines=1 /steps/tags.lst) $tag
            done


            IMAGE_TAG=$(head --lines=1 /steps/tags.lst |  awk -F: '{print $2}')

            echo "**"

            echo "** ibmcloud cr image-digests --restrict
            ${REGISTRY_NAMESPACE}/${IMAGE_NAME}"

            ibmcloud cr image-digests --restrict
            ${REGISTRY_NAMESPACE}/${IMAGE_NAME}

            echo -n "** ibmcloud cr image-digests --restrict
            ${REGISTRY_NAMESPACE}/${IMAGE_NAME}"

            echo " --format '{{ .Repository}}:{{ .Tags }} {{ .Digest }}'"

            ibmcloud cr image-digests --restrict
            ${REGISTRY_NAMESPACE}/${IMAGE_NAME} \
              --format '{{ .Repository}}:{{ .Tags }} {{ .Digest }}'
            echo "**"

            MANIFEST_SHA=$(ibmcloud cr image-digests --restrict
            ${REGISTRY_NAMESPACE}/${IMAGE_NAME} \
              --format '{{ .Repository}}:{{ .Tags }} {{ .Digest }}' | grep "${IMAGE_TAG}" | awk '{print $NF}')

            # Because of https://github.com/tektoncd/pipeline/issues/216

            # the image digest for input is/will always empty

            # there was an alternative/workaround but it is updating using a
            specific account

            # and using a kubectl command to update the resources

            # see https://github.com/nlewo/poc-tekton#deploy-tasks

            #
            https://raw.githubusercontent.com/tektoncd/catalog/0b48da8e336a4214aff46af242658dc056199b1c/update-image-digests/image-digest-updater.yaml

            #
            https://raw.githubusercontent.com/tektoncd/catalog/0b48da8e336a4214aff46af242658dc056199b1c/update-image-digests/update-image-digests.yaml

            # Here the workaround will be to add registry and image information
            in an output properties file

            IMAGE_TAGS=$(sed
            "s#^$REGISTRY_URL/$REGISTRY_NAMESPACE/$IMAGE_NAME:##"
            /steps/tags.lst | \
              tr -s '\r\n' ',' | sed -e 's/,$/\n/')
            if [ "$PROPERTIES_FILE" ]; then
              cd /artifacts
              # Ensure directory is there
              mkdir -p /artifacts/$(dirname "$PROPERTIES_FILE")
              echo "REGISTRY_URL=${REGISTRY_URL}" >> $PROPERTIES_FILE
              echo "REGISTRY_NAMESPACE=${REGISTRY_NAMESPACE}" >> $PROPERTIES_FILE
              echo "REGISTRY_REGION=${REGISTRY_REGION}" >> $PROPERTIES_FILE
              echo "IMAGE_NAME=${IMAGE_NAME}" >> $PROPERTIES_FILE
              echo "IMAGE_TAGS=$IMAGE_TAGS" >> $PROPERTIES_FILE
              echo "IMAGE_MANIFEST_SHA=${MANIFEST_SHA}" >> $PROPERTIES_FILE
              echo "$PROPERTIES_FILE content:"
              cat $PROPERTIES_FILE
            fi


            # Record task results

            echo -n "${REGISTRY_URL}/${REGISTRY_NAMESPACE}/${IMAGE_NAME}" >
            $(results.image-repository.path)

            echo -n "${IMAGE_TAGS}" > $(results.image-tags.path)

            echo -n "${MANIFEST_SHA}" > $(results.image-digest.path)
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
          - mountPath: /scripts
            name: check-registry-scripts
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
      - name: check-registry-scripts
        configMap:
          name: check-registry-scripts
          items:
            - key: check_registry.sh
              path: check_registry.sh
            - key: parse_image_url.sh
              path: parse_image_url.sh
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: icr-execute-in-dind-cluster
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: container-registry-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud container registry
        default: apikey
      - name: ibmcloud-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud
        default: apikey
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: cluster-region
        description: |
          (optional) the ibmcloud region hosting the cluster
          (if value is `` it will default to the toolchain region)
        default: ''
      - name: cluster-name
        description: >-
          name of the docker build cluster - required if no cluster pipeline
          resource provided to this task
        default: ''
      - name: cluster-namespace
        description: >-
          (optional) the kubernetes cluster namespace where the docker engine is
          hosted/deployed
        default: build
      - name: registry-create-namespace
        description: create container registry namespace if it doesn't already exists
        default: 'true'
      - name: image-url
        description: >-
          url of the image to build - required if no image pipeline resource
          provided to this task
        default: ''
      - name: image-tag
        description: the default image tag if none is provided using the built-image url
        default: latest
      - name: path-to-context
        default: .
      - name: path-to-dockerfile
        description: the path to the Docker file
        default: .
      - name: dockerfile
        description: The name of the Dockerfile
        default: Dockerfile
      - name: docker-client-image
        description: The Docker image to use to run the Docker client
        default: docker
      - name: docker-commands
        description: The docker command(s) to run.
        default: >
          # Default docker build / inspect / push command

          docker build --tag "$IMAGE_URL:$IMAGE_TAG" --file
          $PATH_TO_DOCKERFILE/$DOCKERFILE $PATH_TO_CONTEXT

          docker inspect ${IMAGE_URL}:${IMAGE_TAG}

          docker push ${IMAGE_URL}:${IMAGE_TAG}
      - name: properties-file
        description: file containing properties out of the docker in docker task
        default: build.properties
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    results:
      - name: image-repository
        description: the repository for the built image
      - name: image-tags
        description: the tags for the built image
      - name: image-digest
        description: the image digest (sha-256 hash) for the built image
    workspaces:
      - name: source
        description: >-
          A workspace containing the source (Dockerfile, Docker context) to
          create the image
        mountPath: /artifacts
    resources:
      inputs:
        - name: cluster
          type: cluster
          description: (Optional) The cluster used for Docker build
          optional: true
      outputs:
        - name: built-image
          type: image
          description: (Optional) The image to build
          optional: true
    stepTemplate:
      env:
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: check-registry
        image: 'ibmcom/pipeline-base-image:2.6'
        workingDir: /steps
        env:
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.container-registry-apikey-secret-key)
          - name: IBMCLOUD_API
            value: $(params.ibmcloud-api)
          - name: IBMCLOUD_RESOURCE_GROUP
            value: $(params.resource-group)
          - name: REGISTRY_CREATE_NAMESPACE
            value: $(params.registry-create-namespace)
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail

            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################


            if [ "$(resources.outputs.built-image.url)" == "" ]; then
              export IMAGE_RESOURCE_URL="$(params.image-url)"
            else
              export IMAGE_RESOURCE_URL="$(resources.outputs.built-image.url)"
            fi


            # Parse the image url to find registry information

            source /scripts/parse_image_url.sh


            # Ensure login to the container registry and namespace available

            source /scripts/check_registry.sh


            # create a dry-run k8s secret of type docker-registry to obtain

            # the content of a docker config.json file to access the target

            # ibmcloud container registry

            echo "Creating a Kubernetes secret to access the IBM Cloud Container
            Registry."

            kubectl create secret --dry-run=true --output=json \
              docker-registry registry-dockerconfig-secret \
              --docker-server=${REGISTRY_URL} \
              --docker-password=${API_KEY} \
              --docker-username=iamapikey --docker-email=a@b.com | \
            jq -r '.data[".dockerconfigjson"]' | base64 -d > config.json


            echo ""

            echo "Secret created."
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
          - mountPath: /scripts
            name: check-registry-scripts
      - name: run-docker-commands
        image: $(params.docker-client-image)
        workingDir: /artifacts
        env:
          - name: PROPERTIES_FILE
            value: $(params.properties-file)
          - name: PATH_TO_CONTEXT
            value: $(params.path-to-context)
          - name: PATH_TO_DOCKERFILE
            value: $(params.path-to-dockerfile)
          - name: DOCKERFILE
            value: $(params.dockerfile)
          - name: DOCKER_HOST
            value: 'tcp://localhost:2375'
          - name: DOCKER_CONFIG
            value: /steps
          - name: PIPELINE_RUN_NAME
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.labels[''tekton.dev/pipelineRun'']'
          - name: PIPELINE_RUN_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
          - name: PIPELINE_RUN_URL
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-run-url'']'
          - name: BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
          - name: PIPELINE_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-id'']'
          - name: TRIGGER_TYPE
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/trigger-type'']'
          - name: TRIGGER_NAME
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/trigger-name'']'
          - name: TRIGGERED_BY
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/triggered-by'']'
        command:
          - /bin/sh
          - '-c'
        args:
          - >
            set -e -o pipefail


            if [ $PIPELINE_DEBUG == 1 ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi


            if [ "$(resources.outputs.built-image.url)" == "" ]; then
              export IMAGE_RESOURCE_URL="$(params.image-url)"
            else
              export IMAGE_RESOURCE_URL="$(resources.outputs.built-image.url)"
            fi


            # Parse the image url to find information (region, namespace, image
            name and eventually tag)

            # as url of Image PipelineResource is the complete path to the
            image, including the registry

            # and the image tag -
            https://github.com/tektoncd/pipeline/blob/v0.10.1/docs/resources.md#image-resource

            IMAGE_URL=$(echo $IMAGE_RESOURCE_URL |  awk -F: '{print $1}')

            IMAGE_TAG=$(echo $IMAGE_RESOURCE_URL |  awk -F: '{print $2}')

            if [ -z "$IMAGE_TAG" ]; then
              IMAGE_TAG="$(params.image-tag)"
            fi

            echo "Image URL: $IMAGE_URL"

            echo "Image tag: $IMAGE_TAG"

            echo ""


            # run docker command(s) passed as parameter

            echo "Running docker command(s)..."

            echo ""


            $(params.docker-commands)


            echo ""

            # Persist registry and image information in an output properties
            file

            REGISTRY_URL=$(echo $IMAGE_RESOURCE_URL |  awk -F/ '{print $1}')

            REGISTRY_NAMESPACE=$(echo $IMAGE_RESOURCE_URL |  awk -F/ '{print
            $2}')

            # Image name is remaining part after the repository and namespace
            and can contains /

            IMAGE_NAME=$(echo $IMAGE_URL |  awk -F/ '{a=match($0, $3); print
            substr($0,a)}')

            MANIFEST_SHA=$(docker inspect "$IMAGE_URL:$IMAGE_TAG" \
              --format='{{index .RepoDigests 0 }}' | awk -F@ '{print $2}')

            if [ "$PROPERTIES_FILE" ]; then
              # Ensure directory is there
              mkdir -p $(workspaces.source.path)/$(dirname "$PROPERTIES_FILE")
              echo "REGISTRY_URL=${REGISTRY_URL}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "REGISTRY_NAMESPACE=${REGISTRY_NAMESPACE}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "IMAGE_NAME=${IMAGE_NAME}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "IMAGE_TAGS=${IMAGE_TAG}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "IMAGE_MANIFEST_SHA=${MANIFEST_SHA}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "$PROPERTIES_FILE content:"
              cat $(workspaces.source.path)/$PROPERTIES_FILE
              echo ""
            fi


            # Record task results

            echo -n "${IMAGE_URL}" > $(results.image-repository.path)

            echo -n "${IMAGE_TAG}" > $(results.image-tags.path)

            echo -n "${MANIFEST_SHA}" > $(results.image-digest.path)


            echo "Done."
        volumeMounts:
          - mountPath: /steps
            name: steps-volume
    sidecars:
      - name: setup-docker-build-cluster
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: THE_POD_IP
            valueFrom:
              fieldRef:
                fieldPath: status.podIP
          - name: IBM_CLOUD_API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.ibmcloud-apikey-secret-key)
          - name: IBMCLOUD_API
            value: $(params.ibmcloud-api)
          - name: IBMCLOUD_TARGET_RESOURCE_GROUP
            value: $(params.resource-group)
          - name: IBMCLOUD_TARGET_REGION
            value: $(params.cluster-region)
          - name: BUILD_CLUSTER_NAMESPACE
            value: $(params.cluster-namespace)
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail

            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################


            # if target region is not specified, used the toolchain region

            if [ -z "$IBMCLOUD_TARGET_REGION" ]; then
              IBMCLOUD_TARGET_REGION=$(jq -r '.region_id' /cd-config/toolchain.json | awk -F: '{print $3}')
            fi


            # if target region is in the 'ibm:yp:<region>' format just keep the
            region part

            REGION_SUBSET=$(echo "$IBMCLOUD_TARGET_REGION" | awk -F ':' '{print
            $3;}')

            if [ -z "$REGION_SUBSET" ]; then
              echo "IBM Cloud Target Region is $IBMCLOUD_TARGET_REGION"
            else
              export IBMCLOUD_TARGET_REGION=$REGION_SUBSET
              echo "IBM Cloud Target Region is $IBMCLOUD_TARGET_REGION. export IBMCLOUD_TARGET_REGION=$REGION_SUBSET done"
            fi


            echo "Logging in to build cluster account..."

            ibmcloud config --check-version false

            ibmcloud login -a $IBMCLOUD_API --apikey "$IBM_CLOUD_API_KEY" -r
            "$IBMCLOUD_TARGET_REGION"


            if [ -z "$IBMCLOUD_TARGET_RESOURCE_GROUP" ]; then
              echo "Using default resource group"
            else
              ibmcloud target -g "$IBMCLOUD_TARGET_RESOURCE_GROUP"
            fi


            echo "Cluster list:"

            ibmcloud ks clusters


            if [ "$(resources.inputs.cluster.name)" == "" ]; then
              export BUILD_CLUSTER_NAME="$(params.cluster-name)"
            else
              export BUILD_CLUSTER_NAME="$(resources.inputs.cluster.name)"
            fi


            echo "Running ibmcloud ks cluster config --cluster
            "$BUILD_CLUSTER_NAME" --export -s"

            CLUSTER_CONFIG_COMMAND=$(ibmcloud ks cluster config --cluster
            "$BUILD_CLUSTER_NAME" --export -s)

            echo "$CLUSTER_CONFIG_COMMAND"

            eval $CLUSTER_CONFIG_COMMAND


            echo "Checking cluster namespace $BUILD_CLUSTER_NAMESPACE"

            if ! kubectl get namespace "$BUILD_CLUSTER_NAMESPACE"; then
              kubectl create namespace "$BUILD_CLUSTER_NAMESPACE"
            fi


            # Ensure there is a Docker server on the build cluster

            if ! kubectl --namespace "$BUILD_CLUSTER_NAMESPACE" rollout status
            -w deployment/docker-dind; then
              echo "Preparing Docker server deployment"
              cat > /sidecar-only/docker-dind-deployment.yaml << EOF
            apiVersion: apps/v1

            kind: Deployment

            metadata:
              labels:
                run: docker
              name: docker-dind
            spec:
              replicas: 1
              selector:
                matchLabels:
                  run: docker
              template:
                metadata:
                  labels:
                    run: docker
                spec:
                  containers:
                  - name: docker
                    image: docker:dind
                    env:
                    - name: DOCKER_TLS_CERTDIR
                      value: ''
                    securityContext:
                      privileged: true
            EOF
              echo "Installing Docker Server into build cluster..."
              kubectl --namespace "$BUILD_CLUSTER_NAMESPACE" apply -f /sidecar-only/docker-dind-deployment.yaml
              kubectl --namespace "$BUILD_CLUSTER_NAMESPACE" rollout status -w deployment/docker-dind
            fi


            # Use port-forward to make the pod/port locally accessible

            # We need to include the POD IP in the addresses because the
            readinessProbe will try to open

            # a socket on <POD_IP>:PORT

            # Be sure to use a running POD (not an evicted one)

            kubectl --namespace "$BUILD_CLUSTER_NAMESPACE" get pods

            kubectl --namespace "$BUILD_CLUSTER_NAMESPACE" port-forward \
              --address=localhost,${THE_POD_IP} \
              $(kubectl --namespace "$BUILD_CLUSTER_NAMESPACE" get pods | \
                grep docker | grep -i running | awk '{print $1;}' \
               ) \
              2375:2375
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /sidecar-only
            name: sidecar-volume
        readinessProbe:
          tcpSocket:
            port: 2375
          initialDelaySeconds: 3
          periodSeconds: 3
          failureThreshold: 10
    volumes:
      - name: sidecar-volume
        emptyDir: {}
      - name: steps-volume
        emptyDir: {}
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
      - name: check-registry-scripts
        configMap:
          name: check-registry-scripts
          items:
            - key: check_registry.sh
              path: check_registry.sh
            - key: parse_image_url.sh
              path: parse_image_url.sh
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: icr-execute-in-dind
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: container-registry-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud container registry
        default: apikey
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: registry-create-namespace
        description: create container registry namespace if it doesn't already exists
        default: 'true'
      - name: image-url
        description: >-
          url of the image to build - required if no image pipeline resource
          provided to this task
        default: ''
      - name: image-tag
        description: the default image tag if none is provided using the built-image url
        default: latest
      - name: path-to-context
        default: .
      - name: path-to-dockerfile
        description: the path to the Docker file
        default: .
      - name: dockerfile
        description: The name of the Dockerfile
        default: Dockerfile
      - name: docker-client-image
        description: The Docker image to use to run the Docker client
        default: docker
      - name: docker-commands
        description: The docker command(s) to run.
        default: >
          # Default docker build / inspect / push command

          docker build --tag "$IMAGE_URL:$IMAGE_TAG" --file
          $PATH_TO_DOCKERFILE/$DOCKERFILE $PATH_TO_CONTEXT

          docker inspect ${IMAGE_URL}:${IMAGE_TAG}

          docker push ${IMAGE_URL}:${IMAGE_TAG}
      - name: properties-file
        description: file containing properties out of the docker in docker task
        default: build.properties
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    results:
      - name: image-repository
        description: the repository for the built image
      - name: image-tags
        description: the tags for the built image
      - name: image-digest
        description: the image digest (sha-256 hash) for the built image
    workspaces:
      - name: source
        description: >-
          A workspace containing the source (Dockerfile, Docker context) to
          create the image
        mountPath: /artifacts
    resources:
      outputs:
        - name: built-image
          type: image
          description: (Optional) The image to build
          optional: true
    stepTemplate:
      env:
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: check-registry
        image: 'ibmcom/pipeline-base-image:2.6'
        workingDir: /steps
        env:
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.container-registry-apikey-secret-key)
          - name: IBMCLOUD_API
            value: $(params.ibmcloud-api)
          - name: IBMCLOUD_RESOURCE_GROUP
            value: $(params.resource-group)
          - name: REGISTRY_CREATE_NAMESPACE
            value: $(params.registry-create-namespace)
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail

            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################


            if [ "$(resources.outputs.built-image.url)" == "" ]; then
              export IMAGE_RESOURCE_URL="$(params.image-url)"
            else
              export IMAGE_RESOURCE_URL="$(resources.outputs.built-image.url)"
            fi


            # Parse the image url to find registry information

            source /scripts/parse_image_url.sh


            # Ensure login to the container registry and namespace available

            source /scripts/check_registry.sh


            # create a dry-run k8s secret of type docker-registry to obtain

            # the content of a docker config.json file to access the target

            # ibmcloud container registry

            echo "Creating a Kubernetes secret to access the IBM Cloud Container
            Registry."

            kubectl create secret --dry-run=true --output=json \
              docker-registry registry-dockerconfig-secret \
              --docker-server=${REGISTRY_URL} \
              --docker-password=${API_KEY} \
              --docker-username=iamapikey --docker-email=a@b.com | \
            jq -r '.data[".dockerconfigjson"]' | base64 -d > config.json


            echo ""

            echo "Secret created."
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
          - mountPath: /scripts
            name: check-registry-scripts
      - name: run-docker-commands
        image: $(params.docker-client-image)
        workingDir: /artifacts
        env:
          - name: PROPERTIES_FILE
            value: $(params.properties-file)
          - name: PATH_TO_CONTEXT
            value: $(params.path-to-context)
          - name: PATH_TO_DOCKERFILE
            value: $(params.path-to-dockerfile)
          - name: DOCKERFILE
            value: $(params.dockerfile)
          - name: DOCKER_HOST
            value: 'tcp://localhost:2376'
          - name: DOCKER_TLS_VERIFY
            value: '1'
          - name: DOCKER_CERT_PATH
            value: /certs/client
          - name: DOCKER_CONFIG
            value: /steps
          - name: PIPELINE_RUN_NAME
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.labels[''tekton.dev/pipelineRun'']'
          - name: PIPELINE_RUN_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
          - name: PIPELINE_RUN_URL
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-run-url'']'
          - name: BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
          - name: PIPELINE_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-id'']'
          - name: TRIGGER_TYPE
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/trigger-type'']'
          - name: TRIGGER_NAME
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/trigger-name'']'
          - name: TRIGGERED_BY
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/triggered-by'']'
        command:
          - /bin/sh
          - '-c'
        args:
          - >
            set -e -o pipefail


            if [ $PIPELINE_DEBUG == 1 ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi


            if [ "$(resources.outputs.built-image.url)" == "" ]; then
              export IMAGE_RESOURCE_URL="$(params.image-url)"
            else
              export IMAGE_RESOURCE_URL="$(resources.outputs.built-image.url)"
            fi


            # Parse the image url to find information (region, namespace, image
            name and eventually tag)

            # as url of Image PipelineResource is the complete path to the
            image, including the registry

            # and the image tag -
            https://github.com/tektoncd/pipeline/blob/v0.10.1/docs/resources.md#image-resource

            IMAGE_URL=$(echo $IMAGE_RESOURCE_URL |  awk -F: '{print $1}')

            IMAGE_TAG=$(echo $IMAGE_RESOURCE_URL |  awk -F: '{print $2}')

            if [ -z "$IMAGE_TAG" ]; then
              IMAGE_TAG="$(params.image-tag)"
            fi

            echo "Image URL: $IMAGE_URL"

            echo "Image tag: $IMAGE_TAG"

            echo ""


            # run docker command(s) passed as parameter

            echo "Running docker command(s)..."

            echo ""


            $(params.docker-commands)


            echo ""

            # Persist registry and image information in an output properties
            file

            REGISTRY_URL=$(echo $IMAGE_RESOURCE_URL |  awk -F/ '{print $1}')

            REGISTRY_NAMESPACE=$(echo $IMAGE_RESOURCE_URL |  awk -F/ '{print
            $2}')

            # Image name is remaining part after the repository and namespace
            and can contains /

            IMAGE_NAME=$(echo $IMAGE_URL |  awk -F/ '{a=match($0, $3); print
            substr($0,a)}')

            MANIFEST_SHA=$(docker inspect "$IMAGE_URL:$IMAGE_TAG" \
              --format='{{index .RepoDigests 0 }}' | awk -F@ '{print $2}')

            if [ "$PROPERTIES_FILE" ]; then
              # Ensure directory is there
              mkdir -p $(workspaces.source.path)/$(dirname "$PROPERTIES_FILE")
              echo "REGISTRY_URL=${REGISTRY_URL}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "REGISTRY_NAMESPACE=${REGISTRY_NAMESPACE}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "IMAGE_NAME=${IMAGE_NAME}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "IMAGE_TAGS=${IMAGE_TAG}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "IMAGE_MANIFEST_SHA=${MANIFEST_SHA}" >> $(workspaces.source.path)/$PROPERTIES_FILE
              echo "$PROPERTIES_FILE content:"
              cat $(workspaces.source.path)/$PROPERTIES_FILE
              echo ""
            fi


            # Record task results

            echo -n "${IMAGE_URL}" > $(results.image-repository.path)

            echo -n "${IMAGE_TAG}" > $(results.image-tags.path)

            echo -n "${MANIFEST_SHA}" > $(results.image-digest.path)


            echo "Done."
        volumeMounts:
          - mountPath: /steps
            name: steps-volume
          - mountPath: /certs/client
            name: dind-certs
    sidecars:
      - image: 'docker:dind'
        name: server
        securityContext:
          privileged: true
        command:
          - sh
          - '-c'
        env:
          - name: DOCKER_TLS_CERTDIR
            value: /certs
        args:
          - >-
            if [[ $(df -PT /var/lib/docker | awk 'NR==2 {print $2}') == virtiofs
            ]]; then apk add e2fsprogs && truncate -s 20G /tmp/disk.img &&
            mkfs.ext4 /tmp/disk.img && mount /tmp/disk.img /var/lib/docker; fi
            && dockerd-entrypoint.sh --mtu=1400;
        volumeMounts:
          - mountPath: /certs/client
            name: dind-certs
        readinessProbe:
          initialDelaySeconds: 2
          periodSeconds: 1
          exec:
            command:
              - ls
              - /certs/client/ca.pem
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: dind-certs
        emptyDir: {}
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
      - name: check-registry-scripts
        configMap:
          name: check-registry-scripts
          items:
            - key: check_registry.sh
              path: check_registry.sh
            - key: parse_image_url.sh
              path: parse_image_url.sh
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: iks-contextual-execution
  spec:
    params:
      - name: cluster-pipeline-resources-directory
        description: >-
          directory in which the kubeconfig file(s) for clusterPipelineResources
          are available
        default: /clusters
      - name: cluster-name
        description: >-
          name of the cluster - required if no cluster pipeline resource
          provided to this task
        default: ''
      - name: script
        description: >-
          the bash snippet to execute within the context of the kubernetes
          configuration
        default: kubectl version
      - name: pipeline-debug
        default: '0'
    resources:
      inputs:
        - name: cluster
          type: cluster
          optional: true
    workspaces:
      - name: cluster-configuration
        description: A workspace that contain the kubectl cluster config to be used
        mountPath: /clusterconfig
    steps:
      - name: execute
        image: 'ibmcom/pipeline-base-image:2.6'
        workingDir: $(workspaces.cluster-configuration.path)
        env:
          - name: PIPELINE_DEBUG
            value: $(params.pipeline-debug)
          - name: PIPELINE_RUN_NAME
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.labels[''tekton.dev/pipelineRun'']'
          - name: PIPELINE_RUN_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
          - name: PIPELINE_RUN_URL
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-run-url'']'
          - name: BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
          - name: PIPELINE_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-id'']'
          - name: TRIGGER_TYPE
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/trigger-type'']'
          - name: TRIGGER_NAME
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/trigger-name'']'
          - name: TRIGGERED_BY
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/triggered-by'']'
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            if [ $PIPELINE_DEBUG == 1 ]; then
              pwd
              env
              trap env EXIT
              set -x
            fi


            # Find cluster information

            if [ "$(resources.inputs.cluster.name)" == "" ]; then
              export CLUSTER_NAME="$(params.cluster-name)"
            else
              export CLUSTER_NAME="$(resources.inputs.cluster.name)"
            fi

            export
            KUBECONFIG="/clusterconfig/$(params.cluster-pipeline-resources-directory)/$CLUSTER_NAME/kubeconfig"


            # Validate KUBECONFIG

            if test -f "$KUBECONFIG"; then
              echo "KUBECONFIG=$KUBECONFIG"
            else
              echo "$KUBECONFIG file is not existing. Exiting now..."
              exit 1
            fi

            # User-defined snippet/script

            $(params.script)
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
    volumes:
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: iks-deploy-to-kubernetes
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          name of the configmap containing the continuous delivery pipeline
          context secrets
        default: secure-properties
      - name: kubernetes-service-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud kubernetes service
        default: apikey
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: cluster-region
        description: >
          (optional) the ibmcloud region hosting the cluster (if none is found
          it will default to the toolchain region)
        default: ''
      - name: cluster-name
        description: >-
          name of the cluster - required if no cluster pipeline resource
          provided to this task
        default: ''
      - name: image-url
        default: ''
      - name: shuttle-properties-file
        default: ''
      - name: setup-script
        default: ''
      - name: script
        default: ''
      - name: post-execution-script
        default: ''
      - name: pipeline-debug
        default: '0'
    results:
      - name: cluster-name
        description: The cluster name
      - name: cluster-id
        description: The cluster identifier
      - name: resource-group-name
        description: The resource-group name that this cluster is part of
      - name: resource-group-id
        description: The resource-group identifier that this cluster is part of
      - name: region
        description: The region (ie us-south) where the cluster is located
    workspaces:
      - name: artifacts
        description: A workspace
        mountPath: /artifacts
    steps:
      - name: execute
        image: 'ibmcom/pipeline-base-image:2.6'
        workingDir: /artifacts
        env:
          - name: BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
          - name: PIPELINE_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-id'']'
          - name: PIPELINE_STAGE_EXECUTION_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
          - name: PIPELINE_TRIGGERING_USER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/triggered-by'']'
          - name: PIPELINE_BLUEMIX_API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.kubernetes-service-apikey-secret-key)
          - name: PIPELINE_BLUEMIX_RESOURCE_GROUP
            value: $(params.resource-group)
          - name: PIPELINE_KUBERNETES_CLUSTER_NAME
            value: $(params.cluster-name)
          - name: PIPELINE_IMAGE_URL
            value: $(params.image-url)
          - name: SHUTTLE_PROPERTIES_FILE
            value: $(params.shuttle-properties-file)
          - name: PIPELINE_DEBUG
            value: $(params.pipeline-debug)
        script: >
          #!/bin/bash

          set -e -o pipefail


          if [ $PIPELINE_DEBUG == 1 ]; then
              env
              pwd
              ls -l
              echo "=== cat /artifacts/_toolchain.json ==="
              cat /artifacts/_toolchain.json
              echo ""
              echo "======================================"
              trap env EXIT
              set -x
          fi


          # SETUP BEGIN

          ibmcloud config --check-version false

          if [ "$(params.cluster-region)" ]; then
            # if cluster region is in the 'ibm:yp:<region>' just keep the region part
            export IBM_CLOUD_REGION=$(echo "$(params.cluster-region)" | awk -F ':' '{print $NF;}')
          else
            export IBM_CLOUD_REGION=$(jq -r '.region_id' /artifacts/_toolchain.json | awk -F: '{print $3}')
          fi

          ibmcloud login -a $(params.ibmcloud-api) -r $IBM_CLOUD_REGION --apikey
          $PIPELINE_BLUEMIX_API_KEY


          if [ "$PIPELINE_BLUEMIX_RESOURCE_GROUP" ]; then
            ibmcloud target -g "$PIPELINE_BLUEMIX_RESOURCE_GROUP"
          fi


          if ibmcloud ks cluster get --cluster
          $PIPELINE_KUBERNETES_CLUSTER_NAME; then
            eval $(ibmcloud ks cluster config --cluster $PIPELINE_KUBERNETES_CLUSTER_NAME --export -s)
          else
            echo "Cluster $PIPELINE_KUBERNETES_CLUSTER_NAME not found. Accessible clusters are:"
            ibmcloud ks clusters
            exit 1
          fi


          ibmcloud ks cluster get --cluster $PIPELINE_KUBERNETES_CLUSTER_NAME
          --json > /steps/$PIPELINE_KUBERNETES_CLUSTER_NAME.json


          export PIPELINE_TOOLCHAIN_ID=$(jq -r '.toolchain_guid'
          /artifacts/_toolchain.json)


          if [ "$SHUTTLE_PROPERTIES_FILE" ]; then
            source $SHUTTLE_PROPERTIES_FILE
            export $(cut -d= -f1 $SHUTTLE_PROPERTIES_FILE)
          fi


          $(params.setup-script)


          # DO THE WORK

          $(params.script)


          $(params.post-execution-script)


          # Record task results

          echo -n "$(cat /steps/$PIPELINE_KUBERNETES_CLUSTER_NAME.json | jq -r
          '.name')" > $(results.cluster-name.path)

          echo -n "$(cat /steps/$PIPELINE_KUBERNETES_CLUSTER_NAME.json | jq -r
          '.id')" > $(results.cluster-id.path)

          echo -n "$(cat /steps/$PIPELINE_KUBERNETES_CLUSTER_NAME.json | jq -r
          '.resourceGroupName')" > $(results.resource-group-name.path)

          echo -n "$(cat /steps/$PIPELINE_KUBERNETES_CLUSTER_NAME.json | jq -r
          '.resourceGroup')" > $(results.resource-group-id.path)

          echo -n "$(cat /steps/$PIPELINE_KUBERNETES_CLUSTER_NAME.json | jq -r
          '.region')" > $(results.region.path)
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
          - mountPath: /artifacts/_toolchain.json
            subPath: toolchain.json
            name: cd-config-volume
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: iks-fetch-config
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: kubernetes-service-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud kubernetes service
        default: apikey
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: cluster-region
        description: >
          (optional) the ibmcloud region hosting the cluster (if none is found
          it will default to the toolchain region)
        default: ''
      - name: cluster-name
        description: >-
          name of the cluster - required if no cluster pipeline resource
          provided to this task
        default: ''
      - name: kube-api-server-accessible
        description: >
          indicates if the kubeAPIServer is exposed which is not the case for
          IBM Cloud Public Shared Workers

          (Calico network policy). If 'true', the task is trying to update the
          Cluster Pipeline Resources definition

          with the appropriate informations; When 'false', the fallback
          mechanism (copy file(s)) is used.
        default: 'false'
      - name: cluster-pipeline-resources-directory-fallback
        description: >-
          directory in the workspace that will be used as a fallback mechanism
          to store the kubeconfig file
        default: .tekton-cluster-pipeline-resources
      - name: cluster-and-worker-nodes-json-export
        description: >-
          directory in the workspace that will be used to store the cluster and
          worker nodes export json files
        default: ''
      - name: pipeline-debug
        default: '0'
    resources:
      inputs:
        - name: cluster
          type: cluster
          optional: true
      outputs:
        - name: cluster
          type: cluster
          optional: true
    results:
      - name: cluster-name
        description: The cluster name
      - name: cluster-id
        description: The cluster identifier
      - name: resource-group-name
        description: The resource-group name that this cluster is part of
      - name: resource-group-id
        description: The resource-group identifier that this cluster is part of
      - name: region
        description: The region (ie us-south) where the cluster is located
    workspaces:
      - name: cluster-configuration
        description: A workspace where the kubernetes cluster config is exported
        mountPath: /clusterconfig
    steps:
      - name: setup
        image: 'ibmcom/pipeline-base-image:2.6'
        workingDir: /clusterconfig
        env:
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.kubernetes-service-apikey-secret-key)
          - name: NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
          - name: PIPELINE_DEBUG
            value: $(params.pipeline-debug)
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail


            if [ $PIPELINE_DEBUG == 1 ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi


            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################

            ibmcloud config --check-version false

            if [ "$(params.cluster-region)" ]; then
              # if cluster region is in the 'ibm:yp:<region>' just keep the region part
              TARGET_REGION=$(echo "$(params.cluster-region)" | awk -F ':' '{print $NF;}')
            else
              TARGET_REGION=$(jq -r '.region_id' /cd-config/toolchain.json | awk -F: '{print $3}')
            fi

            ibmcloud login -a $(params.ibmcloud-api) -r $TARGET_REGION --apikey
            $API_KEY

            if [ "$(params.resource-group)" ]; then
              ibmcloud target -g "$(params.resource-group)"
            fi

            # Look for the cluster

            if [ "$(resources.inputs.cluster.name)" == "" ]; then
              export CLUSTER_NAME="$(params.cluster-name)"
            else
              export CLUSTER_NAME="$(resources.inputs.cluster.name)"
            fi

            if ibmcloud ks cluster get --cluster $CLUSTER_NAME; then
              KUBECONFIG_FILE=$(ibmcloud ks cluster config --cluster $CLUSTER_NAME --export -s | awk -F= '{print $2}')
            else
              echo "Cluster $CLUSTER_NAME not found. Accessible clusters are:"
              ibmcloud ks clusters
              exit 1
            fi


            # PipelineResource Cluster are managed appropriately as input
            resources

            # but not as output resources, attempting to update the
            PipelineResource Cluster

            # that has been given (using kubectl patch commands)

            # Verifying the access to pipeline resources

            updateClusterPipelineResource="false"

            if [ "$(params.kube-api-server-accessible)" == "true" ]; then
              if kubectl auth can-i get pipelineresources.tekton.dev > /dev/null 2>&1; then
                updateClusterPipelineResource="true"
              fi
            fi

            if [ "$updateClusterPipelineResource" == "true" ]; then
              # TODO Need to update the Cluster Pipeline Resource with this values
              # This can only be done when TriggerTemplate#resourcetemplates will accept
              # Role and Binding K8S resources definition
              echo "TODO - Processing $KUBECONFIG_FILE"
              K8S_USER_NAME=$(yq r $KUBECONFIG_FILE users[0].name)
              K8S_USER_TOKEN=$(yq r $KUBECONFIG_FILE users[0].user.auth-provider.config.id-token)
              K8S_CLUSTER_URL=$(yq r $KUBECONFIG_FILE clusters[0].cluster.server)
              CA_PEM_FILE="$(dirname $KUBECONFIG_FILE)/$(yq r $KUBECONFIG_FILE clusters[0].cluster.certificate-authority)"
              K8S_CLUSTER_CADATA=$(base64 -w0 $CA_PEM_FILE)
              echo "K8S_USER_NAME=$K8S_USER_NAME"
              #echo "K8S_USER_TOKEN=$K8S_USER_TOKEN"
              echo "K8S_CLUSTER_URL=$K8S_CLUSTER_URL"
              #echo "K8S_CLUSTER_CADATA=$K8S_CLUSTER_CADATA"
            else
              echo "Access to pipelineresources.tekton.dev is required to update Cluser Pipeline Resource accordingly"
              echo "Falling back to copy of $(basename $KUBECONFIG_FILE) to the pipeline run volume"
              mkdir -p /clusterconfig/$(params.cluster-pipeline-resources-directory-fallback)/$CLUSTER_NAME
              cp $(dirname $KUBECONFIG_FILE)/$(yq r $KUBECONFIG_FILE clusters[0].cluster.certificate-authority) \
                /clusterconfig/$(params.cluster-pipeline-resources-directory-fallback)/$CLUSTER_NAME
              cp $KUBECONFIG_FILE \
                /clusterconfig/$(params.cluster-pipeline-resources-directory-fallback)/$CLUSTER_NAME/kubeconfig
              echo -n "Kubeconfig file(s) copied to "
              echo "/clusterconfig/$(params.cluster-pipeline-resources-directory-fallback)/$CLUSTER_NAME"
            fi


            ibmcloud ks cluster get --cluster $CLUSTER_NAME --json >
            /steps/$CLUSTER_NAME.json


            if [ "$(params.cluster-and-worker-nodes-json-export)" ]; then
              mkdir -p /clusterconfig/$(params.cluster-and-worker-nodes-json-export)/$CLUSTER_NAME
              cp /steps/$CLUSTER_NAME.json \
                /clusterconfig/$(params.cluster-and-worker-nodes-json-export)/$CLUSTER_NAME/$CLUSTER_NAME.json
              ibmcloud ks worker ls --cluster $CLUSTER_NAME --json \
                > /clusterconfig/$(params.cluster-and-worker-nodes-json-export)/$CLUSTER_NAME/$CLUSTER_NAME-workers.json
            fi


            # Record task results

            echo -n "$(cat /steps/$CLUSTER_NAME.json | jq -r '.name')" >
            $(results.cluster-name.path)

            echo -n "$(cat /steps/$CLUSTER_NAME.json | jq -r '.id')" >
            $(results.cluster-id.path)

            echo -n "$(cat /steps/$CLUSTER_NAME.json | jq -r
            '.resourceGroupName')" > $(results.resource-group-name.path)

            echo -n "$(cat /steps/$CLUSTER_NAME.json | jq -r '.resourceGroup')"
            > $(results.resource-group-id.path)

            echo -n "$(cat /steps/$CLUSTER_NAME.json | jq -r '.region')" >
            $(results.region.path)
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: toolchain-extract-value
  spec:
    params:
      - name: config-map-name
        description: name of the config map
        default: toolchain
      - name: config-map-key
        description: key of the config map
        default: toolchain.json
      - name: expression
        description: A valid jq expression which is used to search
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
      - name: raw
        description: determines if extracted value should be a raw string
        default: '1'
    results:
      - name: extracted-value
        description: The extracted value
    stepTemplate:
      env:
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: extract-value-jq
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: RAW
            value: $(params.raw)
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            #!/bin/bash

            set -e -o pipefail;


            if [ $PIPELINE_DEBUG == 1 ]; then
              pwd
              env
              trap env EXIT
              set -x
            fi


            jq $([ "$RAW" == 1 ] && echo -r) '$(params.expression)'
            /cd-config/$(params.config-map-key) | tr -d '\n' | tee
            $(results.extracted-value.path)


            file_size=$(du -b $(results.extracted-value.path) | awk '{print
            $1}')

            file_lines=$(wc -l $(results.extracted-value.path) | awk '{print
            $1}')


            if [ $file_lines -gt 80 ] || [ $file_size -gt 2048 ]; then
              echo "Error: The extracted value is over 2048 Bytes or 80 lines - It can't be stored in result."
              exit 1
            fi
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
    volumes:
      - name: cd-config-volume
        configMap:
          name: $(params.config-map-name)
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: toolchain-publish-deployable-mapping
  spec:
    params:
      - name: deployable-type
        description: |
          type of the deployable. Can be either:
          - `app` for a CF application
          or
          - `kubernetes_cluster` for K8S deployment
      - name: deployable-region-id
        description: >
          IBM Cloud Region where the deployable is located.

          A fully qualified id is expected (such as ibm:yp:us-south)

          If not fully qualified, the ibmcloud production prefix is appended (ie
          'ibm:yp:')
      - name: deployable-guid
        description: GUID of the deployable (either cluster guid or cf app guid)
      - name: deployable-cf-org-id
        description: CF organization id (only required when deployable-type is `app`)
        default: ''
      - name: deployable-cf-org-name
        description: >
          CF organization name (only required when deployable-type is `app`).

          It will only be used for traceability event purpose. Default to
          `deployable-cf-org-id`
        default: ''
      - name: deployable-cf-space-id
        description: CF space id (only required when deployable-type is `app`)
        default: ''
      - name: deployable-cf-space-name
        description: >
          CF space name (only required when deployable-type is `app`).

          It will only be used for traceability event purpose. Default to
          `deployable-cf-space-id`
        default: ''
      - name: deployable-rg-id
        description: >-
          Resource Group id (only required when deployable-type is
          `kubernetes_cluster`)
        default: ''
      - name: git-inputs
        description: >
          list of git repository,commit and branch triple (repository,commit id
          and branch spearated by a comma).

          each triple-element of the list is contained in one line
        default: ''
      - name: environment-label
        description: the label of the environment where the deployment has occured
        default: label of the deployed environment
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          Name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: toolchain-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to access toolchain
          and DOI instance
        default: toolchain-apikey
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    steps:
      - name: publish-deployable-mapping
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: DEPLOYABLE_TYPE
            value: $(params.deployable-type)
          - name: DEPLOYABLE_GUID
            value: $(params.deployable-guid)
          - name: REGION_ID
            value: $(params.deployable-region-id)
          - name: RESOURCE_GROUP_ID
            value: $(params.deployable-rg-id)
          - name: CF_ORG_ID
            value: $(params.deployable-cf-org-id)
          - name: CF_ORG_NAME
            value: $(params.deployable-cf-org-name)
          - name: CF_SPACE_ID
            value: $(params.deployable-cf-space-id)
          - name: CF_SPACE_NAME
            value: $(params.deployable-cf-space-name)
          - name: GIT_INPUTS
            value: $(params.git-inputs)
          - name: ENVIRONMENT_LABEL
            value: $(params.environment-label)
          - name: PIPELINE_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-id'']'
          - name: IBM_CLOUD_API
            value: $(params.ibmcloud-api)
          - name: IBM_CLOUD_API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.toolchain-apikey-secret-key)
                optional: true
          - name: PIPELINE_DEBUG
            value: $(params.pipeline-debug)
        script: >
          #!/bin/bash

          set -e -o pipefail

          if [ $PIPELINE_DEBUG == 1 ]; then
              pwd
              env
              trap env EXIT
              set -x
          fi

          ##########################################################################

          # Setting HOME explicitly to have ibmcloud plugins available

          # doing the export rather than env definition is a workaround

          # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

          export HOME="/root"

          ##########################################################################

          TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)

          TOOLCHAIN_REGION_ID=$(jq -r '.region_id' /cd-config/toolchain.json)

          TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json | awk
          -F: '{print $3}')


          ibmcloud config --check-version false

          ibmcloud login -a $(params.ibmcloud-api) -r $TOOLCHAIN_REGION --apikey
          $IBM_CLOUD_API_KEY

          TOKEN=$(ibmcloud iam oauth-tokens --output JSON | jq -r '.iam_token')


          if [ $(echo "$REGION_ID" | grep -c ':' -) -ne 1 ]; then
            # no ':' found so append ibmcloud production prefix to region id
            export REGION_ID="ibm:yp:$REGION_ID"
          fi


          echo "{}" | jq '.deployable={} | .toolchain={} | .source={}' >
          deployable_mapping.json


          cat deployable_mapping.json | \

          jq --arg DEPL_TYPE "$DEPLOYABLE_TYPE" --arg REGION_ID "$REGION_ID" \
             --arg DEPL_GUID "$DEPLOYABLE_GUID" \
            '.deployable.type=$DEPL_TYPE | .deployable.region_id=$REGION_ID | .deployable.deployable_guid=$DEPL_GUID' \
            > tmp_deployable_mapping.json
          mv -f tmp_deployable_mapping.json deployable_mapping.json


          if [ "$DEPLOYABLE_TYPE" == "app" ]; then
            cat deployable_mapping.json | jq --arg ORG_ID "$CF_ORG_ID" \
              --arg SPACE_ID "$CF_SPACE_ID" \
              '.deployable.organization_guid=$ORG_ID | .deployable.space_guid=$SPACE_ID' > tmp_deployable_mapping.json
            mv -f tmp_deployable_mapping.json deployable_mapping.json
          elif [ "$DEPLOYABLE_TYPE" == "kubernetes_cluster" ]; then
            cat deployable_mapping.json | jq --arg RG_ID "$RESOURCE_GROUP_ID" \
              '.deployable.container={} | .deployable.container.guid=$RG_ID | .deployable.container.type="resource_group_id"' \
              > tmp_deployable_mapping.json
            mv -f tmp_deployable_mapping.json deployable_mapping.json
          else
            echo "Deployable type $DEPLOYABLE_TYPE not expected"
            exit 1
          fi


          cat deployable_mapping.json | jq --arg TC_ID "$TOOLCHAIN_ID" --arg
          REGION_ID "$TOOLCHAIN_REGION_ID" \
            '.toolchain.toolchain_guid=$TC_ID | .toolchain.region_id=$REGION_ID ' > tmp_deployable_mapping.json
          mv -f tmp_deployable_mapping.json deployable_mapping.json


          cat deployable_mapping.json | jq --arg PIPELINE_ID "$PIPELINE_ID" \
            '.source.type="service_instance" | .source.source_guid=$PIPELINE_ID ' > tmp_deployable_mapping.json
          mv -f tmp_deployable_mapping.json deployable_mapping.json


          # Manage the experimental section

          if [ "$GIT_INPUTS" ]; then
            cat deployable_mapping.json | jq '.experimental={} | .experimental.env={} | .experimental.inputs=[]' > tmp_deployable_mapping.json
            mv -f tmp_deployable_mapping.json deployable_mapping.json

            # Deploy environment's label
            if [ "$DEPLOYABLE_TYPE" == "app" ]; then
              # Add specific cloud foundry information describing the Cloud Foundry deployment environment
              REGION_NAME=$(echo $REGION_ID | awk -F: '{print $NF}')
              cat deployable_mapping.json | jq --arg ORG_NAME "${CF_ORG_NAME:-$CF_ORG_ID}" --arg SPACE_NAME "${CF_SPACE_NAME:-$CF_SPACE_ID}" \
                --arg REGION_NAME "$REGION_NAME" --arg REGION_ID "$REGION_ID" \
                '.experimental.env.org_name=$ORG_NAME | .experimental.env.space_name=$SPACE_NAME | .experimental.env.region_name=$REGION_NAME | .experimental.env.region_id=$REGION_ID' > tmp_deployable_mapping.json
              mv -f tmp_deployable_mapping.json deployable_mapping.json
            fi
            cat deployable_mapping.json | jq --arg LABEL "$ENVIRONMENT_LABEL" '.experimental.env.label=$LABEL' > tmp_deployable_mapping.json
            mv -f tmp_deployable_mapping.json deployable_mapping.json

            while IFS= read -r git_input
            do
              if [ "$git_input" ]; then
                input_repository=$(echo $git_input | awk -F, '{print $1}')
                if [[ "$input_repository" != *.git ]]; then
                  input_repository="${input_repository}.git"
                fi
                input_commit=$(echo $git_input | awk -F, '{print $2}')
                input_branch=$(echo $git_input | awk -F, '{print $3}')

                input_service_instance_id=$(jq -r --arg git_repo "$input_repository" \
                  '.services[] | select (.parameters.repo_url==$git_repo) | .instance_id' /cd-config/toolchain.json)

                input_service_type=$(jq -r --arg git_repo "$input_repository" \
                  '.services[] | select (.parameters.repo_url==$git_repo) | .service_id' /cd-config/toolchain.json)

                repo_wo_git_suffix=${input_repository%".git"}

                if [ "$input_service_type" == "github" ]; then
                  input_revision_url="${repo_wo_git_suffix}/commit/${input_commit}"
                elif [ "$input_service_type" == "githubpublic" ]; then
                  input_revision_url="${repo_wo_git_suffix}/commit/${input_commit}"
                elif [ "$input_service_type" == "hostedgit" ]; then
                  input_revision_url="${repo_wo_git_suffix}/commit/${input_commit}"
                elif [ "$input_service_type" == "gitlab" ]; then
                  input_revision_url="${repo_wo_git_suffix}/commit/${input_commit}"
                elif [ "$input_service_type" == "bitbucketgit" ]; then
                  input_revision_url="${repo_wo_git_suffix}/commits/${input_commit}"
                else
                  # default for githubconsolidated
                  input_revision_url="${repo_wo_git_suffix}/commit/${input_commit}"
                fi

                # revision timestamp is not used in traceability event notification
                timestamp=""

                cat deployable_mapping.json | jq --arg SI_ID "$input_service_instance_id" --arg REPO "$input_repository" \
                  --arg TS "$timestamp" --arg BRANCH "$input_branch" --arg REVISION_URL "$input_revision_url" \
                  '. as $root | {service_instance_id:$SI_ID} | .data={} | .data.repo_url=$REPO | .data.repo_branch=$BRANCH | .data.timestamp=$TS | .data.revision_url=$REVISION_URL | . as $element | $root | .experimental.inputs += [$element]' \
                  > tmp_deployable_mapping.json
                mv -f tmp_deployable_mapping.json deployable_mapping.json
              fi
            done < <(printf '%s\n' "$GIT_INPUTS")          
          fi


          if [ $IBM_CLOUD_API == "https://test.cloud.ibm.com" ]; then
            OTC_API_DM_URL="https://otc-api.${TOOLCHAIN_REGION}.devops.dev.cloud.ibm.com/api/v1/toolchain_deployable_mappings"
          else
            OTC_API_DM_URL="https://otc-api.${TOOLCHAIN_REGION}.devops.cloud.ibm.com/api/v1/toolchain_deployable_mappings"
          fi


          # Check if an existing mapping exist with the given deployable guid in
          toolchain

          EXISTING_DEPLOYABLE_MAPPING=$(curl -H "accept: application/json" -H
          "Authorization: ${TOKEN}" \
            "$OTC_API_DM_URL?toolchain_guid=${TOOLCHAIN_ID}&deployable_guid=${DEPLOYABLE_GUID}" | \
            jq -r '.items[0].mapping_guid')

          if [ "$EXISTING_DEPLOYABLE_MAPPING" == "null" ]; then
            HTTP_VERB="POST"
            URL_DM_SEGMENT=""
          else
            echo "Existing deployable mapping id found: $EXISTING_DEPLOYABLE_MAPPING"
            HTTP_VERB="PUT"
            URL_DM_SEGMENT="/$EXISTING_DEPLOYABLE_MAPPING"
          fi


          echo "Doing cURL -X $HTTP_VERB $OTC_API_DM_URL$URL_DM_SEGMENT with
          json payload:"

          cat deployable_mapping.json


          HTTP_STATUS_CODE=$(
            curl -s -o /dev/null -w '%{http_code}' -X $HTTP_VERB \
            -H "Authorization: ${TOKEN}" -H "content-type: application/json" \
            -d @deployable_mapping.json $OTC_API_DM_URL$URL_DM_SEGMENT \
          )


          if [ "$HTTP_STATUS_CODE" == "201" ] || [ "$HTTP_STATUS_CODE" == "204"
          ]; then
            echo "Deployable mapping created/updated. HTTP Status code = $HTTP_STATUS_CODE"
          else
            echo "Fail to create deployable mapping ! HTTP Status code = $HTTP_STATUS_CODE"
            exit 1
          fi
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: cra-bom
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: repository
        description: the git repo url
      - name: revision
        description: the revision
        default: master
      - name: commit-id
        description: git commit id
      - name: pr-url
        description: pull request html url
        default: ''
      - name: ibmcloud-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud
        default: apikey
      - name: continuous-delivery-context-secret
        description: Reference name for the secret resource
        default: secure-properties
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: git-access-token
        description: >
          (optional) token to access the git repository. If this token is
          provided, there will not be an attempt

          to use the git token obtained from the authorization flow when adding
          the git integration in the toolchain
        default: ''
      - name: target-branch
        description: target branch
        default: ''
      - name: target-commit-id
        description: target branch commit id
        default: ''
      - name: project-id
        description: 'for gitlab repository, specify project-id'
        default: ''
      - name: scm-type
        description: 'source code type used (github, github-ent, gitlab)'
        default: github-ent
      - name: pipeline-debug
        description: toggles debug mode for the pipeline
        default: '0'
    results:
      - name: status
        description: 'status of bom task, possible value are-success|failure'
      - name: evidence-store
        description: filepath to store bom task evidence
    stepTemplate:
      env:
        - name: PIPELINE_RUN_ID
          valueFrom:
            fieldRef:
              fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: bom
        image: 'icr.io/continuous-delivery/cra-bom:main.1258'
        env:
          - name: REPOSITORY
            value: $(params.repository)
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.ibmcloud-apikey-secret-key)
                optional: true
        imagePullPolicy: Always
        workingDir: /artifacts
        command:
          - /bin/sh
          - '-c'
        args:
          - >
            #!/bin/sh


            if [ "$PIPELINE_DEBUG" == "1" ]; then
              pwd
              env
              trap env EXIT
              set -x +e
            fi


            TOOLCHAIN_CONFIG=$(cat /config/toolchain.json)

            TOOLCHAIN_REGION=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.region_id' |
            awk -F: '{print $3}')

            TOOLCHAIN_ID=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.toolchain_guid')

            REGION_ID=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.region_id')


            API_ENDPOINT="https://cloud.ibm.com"

            OTC_BROKER_BASE_URL="https://otcbroker.devopsinsights.cloud.ibm.com"

            if echo "${REGION_ID}" | grep -q "ys1"; then
              OTC_BROKER_BASE_URL="https://otcbroker.devopsinsights.dev.cloud.ibm.com"
              API_ENDPOINT="https://test.cloud.ibm.com"
              echo "targeting otc broker @ ${OTC_BROKER_BASE_URL}"
              echo "targeting ibm cloud @ ${API_ENDPOINT}"
            fi


            echo "Fetching users's token"

            ibmcloud config --check-version false

            ibmcloud login -a $API_ENDPOINT -r $TOOLCHAIN_REGION --apikey
            $API_KEY

            export IBM_CLOUD_BEARER=$(ibmcloud iam oauth-tokens --output JSON |
            jq -r '.iam_token' | awk '{ print $2 }')


            echo "Fetching service urls for user's data"

            HTTP_RESPONSE=$(curl --silent --write-out "HTTPSTATUS:%{http_code}"
            \
              -X GET "${OTC_BROKER_BASE_URL}/globalauth/toolchainids/${TOOLCHAIN_ID}" \
              --header "Authorization: Bearer ${IBM_CLOUD_BEARER}")
            HTTP_STATUS=$(echo $HTTP_RESPONSE | tr -d '\n' | sed -e
            's/.*HTTPSTATUS://')


            if [ "$HTTP_STATUS" -eq 401 -o "$HTTP_STATUS" -eq 403 ]; then
              echo ""
              echo "Error authenticating user for toolchain_id: ${TOOLCHAIN_ID}"
              echo "Please verify the Devops Insights card has been added to your toolchain and the api-key has access."
              exit 1
            fi


            if [ "$HTTP_STATUS" -ne 200 ]; then
              echo ""
              echo "Error! Please try again."
              exit 1
            fi


            HTTP_BODY=$(echo $HTTP_RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')

            gitsecureUrl=$(echo ${HTTP_BODY} | jq -r '.service_urls.gitsecure')


            if [ -z "$gitsecureUrl" -o "$gitsecureUrl" = "null" ]; then
              echo ""
              echo "Error IBM Code Risk Analyzer is not supported in ${REGION_ID}"
              exit 1
            fi


            uiUrl=$(echo ${HTTP_BODY} | jq -r '.service_urls.controlcenter')


            if [ -z "$uiUrl" -o "$uiUrl" = "null" ]; then
              echo "Error fetching the ui url."
              exit 1
            fi


            sudo --preserve-env /gitsecure/bom-task \
              -giturl "$(params.repository)" \
              -gitbranch "$(params.revision)" \
              -rigserviceapi ${gitsecureUrl} \
              -ui_url ${uiUrl} \
              -pr "$(params.pr-url)" \
              -runid "$PIPELINE_RUN_ID" \
              -commitid "$(params.commit-id)" \
              -target_commitid "$(params.target-commit-id)" \
              -target_branch "$(params.target-branch)" \
              -results_status "$(results.status.path)" \
              -results_evidence "./gitsecure-cis-results.json" \
              -toolchainid "${TOOLCHAIN_ID}" \
              -comment_md "./gitsecure-bom-comment.md"

            echo -n "gitsecure-bom-results.json" >
            $(results.evidence-store.path)

            echo "COMMENT_FP=./gitsecure-bom-comment.md" >>
            /steps/next-step-env.properties
        volumeMounts:
          - mountPath: /config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
      - name: fetch-git-information
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: REPOSITORY
            value: $(params.repository)
          - name: API_ENDPOINT
            value: $(params.ibmcloud-api)
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.ibmcloud-apikey-secret-key)
                optional: true
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail

            if [ "$PIPELINE_DEBUG" == "1" ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi

            TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')

            REGION_ID=$(jq -r '.region_id' /cd-config/toolchain.json)

            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################

            if [[ "$REPOSITORY" != *.git ]]; then
              echo "Adding .git suffix to Repository URL"
              REPOSITORY="${REPOSITORY}.git"
            fi

            GIT_SERVICE_INSTANCE_ID=$(jq -r --arg git_repo "$REPOSITORY"
            '.services[] | select (.parameters.repo_url==$git_repo) |
            .instance_id' /cd-config/toolchain.json)

            if [ -z "$GIT_SERVICE_INSTANCE_ID" ]; then
              echo "No Git integration (repository url: $REPOSITORY) found in the toolchain"
              exit 1
            fi

            GIT_SERVICE_TYPE=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .service_id'
            /cd-config/toolchain.json)

            if [ "$GIT_SERVICE_TYPE" == "github" ]; then
              GIT_AUTH_USER="x-oauth-basic"
            elif [ "$GIT_SERVICE_TYPE" == "githubpublic" ]; then
              GIT_AUTH_USER="x-oauth-basic"
            elif [ "$GIT_SERVICE_TYPE" == "hostedgit" ]; then
              GIT_AUTH_USER="oauth2"
            elif [ "$GIT_SERVICE_TYPE" == "gitlab" ]; then
              GIT_AUTH_USER="oauth2"
            elif [ "$GIT_SERVICE_TYPE" == "bitbucketgit" ]; then
              GIT_AUTH_USER="x-token-auth"
            else
              GIT_AUTH_USER="x-token-auth"
            fi;

            GIT_TOKEN="$(params.git-access-token)"

            if [ -z "$GIT_TOKEN" ]; then
              if [[ "$REGION_ID" == *"ys1"* ]]; then
                API_ENDPOINT="https://test.cloud.ibm.com"
                echo "targeting ibm cloud @ ${API_ENDPOINT}"
              fi
              echo "Fetching token for $REPOSITORY"
              ibmcloud config --check-version false
              ibmcloud login -a $API_ENDPOINT -r $TOOLCHAIN_REGION --apikey $API_KEY
              if [ "$(params.resource-group)" ]; then
                ibmcloud target -g $(params.resource-group)
              fi
              TOKEN=$(ibmcloud iam oauth-tokens --output JSON | jq -r '.iam_token')
              GIT_TOKEN_URL=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.token_url' /cd-config/toolchain.json)
              # GIT_TOKEN_URL is like https://otc-github-consolidated-broker.us-south.devops.cloud.ibm.com/github/token?git_id=github
              # as there is already an url param git_id, just put the additional ones using &
              echo "Doing cURL to ${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
              curl -s -o /steps/github_token_result.json -X GET -H "Accept: application/json" -H "Authorization: $TOKEN" "${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
              if jq -e '.access_token' /steps/github_token_result.json > /dev/null 2>&1; then
                GIT_TOKEN=$(jq -r '.access_token' /steps/github_token_result.json)
                echo "Access token found for the Git integration (repository url: $REPOSITORY)"
              else
                echo "No access token found for the Git integration (repository url: $REPOSITORY)"
                cat /steps/github_token_result.json
                exit 1
              fi
            else
              echo "Using git Access Token provided"
            fi

            GIT_API_ROOT_URL=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .parameters.api_root_url'
            /cd-config/toolchain.json)

            GIT_OWNER_ID=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .parameters.owner_id'
            /cd-config/toolchain.json)

            GIT_REPO_NAME=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .parameters.repo_name'
            /cd-config/toolchain.json)

            GIT_ID=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select
            (.parameters.repo_url==$git_repo) | .parameters.git_id'
            /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')

            echo "GIT_REPOSITORY=$REPOSITORY" >> /steps/next-step-env.properties

            echo "GIT_AUTH_USER=$GIT_AUTH_USER" >>
            /steps/next-step-env.properties

            echo "GIT_TOKEN=$GIT_TOKEN" >> /steps/next-step-env.properties

            echo "GIT_SERVICE_TYPE=$GIT_SERVICE_TYPE" >>
            /steps/next-step-env.properties

            echo "GIT_ID=$GIT_ID" >> /steps/next-step-env.properties

            echo "GIT_API_ROOT_URL=$GIT_API_ROOT_URL" >>
            /steps/next-step-env.properties

            echo "GIT_OWNER_ID=$GIT_OWNER_ID" >> /steps/next-step-env.properties

            echo "GIT_REPO_NAME=$GIT_REPO_NAME" >>
            /steps/next-step-env.properties

            echo "TOOLCHAIN_REGION=$TOOLCHAIN_REGION" >>
            /steps/next-step-env.properties

            if [ "$PIPELINE_DEBUG" == "1" ]; then
              cat /steps/next-step-env.properties
            fi
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
      - name: comment-editor
        image: 'icr.io/continuous-delivery/cra-comm-editor:main.1260'
        imagePullPolicy: Always
        workingDir: /artifacts
        command:
          - /bin/sh
          - '-c'
        args:
          - |
            #!/bin/sh
            source /steps/next-step-env.properties

            /usr/local/bin/comm-editor \
              -repo-url "$(params.repository)" \
              -pr-url "$(params.pr-url)" \
              -token "$GIT_TOKEN" \
              -comment-fp "$COMMENT_FP" \
              -project-id "$(params.project-id)" \
              -scm-type "$(params.scm-type)"
        volumeMounts:
          - mountPath: /steps
            name: steps-volume
    workspaces:
      - name: artifacts
        mountPath: /artifacts
      - name: secrets
        mountPath: /secrets
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: secrets
        secret:
          secretName: $(params.continuous-delivery-context-secret)
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: cra-cis-check
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: repository
        description: the git repo
      - name: revision
        description: the revision
        default: master
      - name: commit-id
        description: git commit id
      - name: pr-url
        description: pull request html url
        default: ''
      - name: ibmcloud-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud
        default: apikey
      - name: continuous-delivery-context-secret
        description: Reference name for the secret resource
        default: secure-properties
      - name: git-access-token
        description: >
          (optional) token to access the git repository. If this token is
          provided, there will not be an attempt

          to use the git token obtained from the authorization flow when adding
          the git integration in the toolchain
        default: ''
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: project-id
        description: for gitlab repository specify project-id
        default: ''
      - name: directory-name
        description: directory name where the repository is cloned
      - name: scm-type
        description: 'source code type used (github, github-ent, gitlab)'
        default: github-ent
      - name: pipeline-debug
        description: toggles debug mode for the pipeline
        default: '0'
    results:
      - name: status
        description: 'status of cis task, possible value are-success|failure'
      - name: evidence-store
        description: filepath to store cis task evidence
    stepTemplate:
      env:
        - name: PIPELINE_RUN_ID
          valueFrom:
            fieldRef:
              fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: cis
        image: 'icr.io/continuous-delivery/cra-cis:main.1262'
        env:
          - name: REPOSITORY
            value: $(params.repository)
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.ibmcloud-apikey-secret-key)
                optional: true
        imagePullPolicy: Always
        workingDir: /artifacts
        command:
          - /bin/sh
          - '-c'
        args:
          - >
            #!/bin/sh

            if [ "$PIPELINE_DEBUG" == "1" ]; then
              pwd
              env
              trap env EXIT
              set -x +e
            fi


            REPO_DIR_PATH="/artifacts/$(params.directory-name)"


            TOOLCHAIN_CONFIG=$(cat /config/toolchain.json)

            TOOLCHAIN_REGION=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.region_id' |
            awk -F: '{print $3}')

            TOOLCHAIN_ID=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.toolchain_guid')

            REGION_ID=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.region_id')


            API_ENDPOINT="https://cloud.ibm.com"

            OTC_BROKER_BASE_URL="https://otcbroker.devopsinsights.cloud.ibm.com"

            if echo "${REGION_ID}" | grep -q "ys1"; then
              OTC_BROKER_BASE_URL="https://otcbroker.devopsinsights.dev.cloud.ibm.com"
              API_ENDPOINT="https://test.cloud.ibm.com"
              echo "targeting otc broker @ ${OTC_BROKER_BASE_URL}"
              echo "targeting ibm cloud @ ${API_ENDPOINT}"
            fi


            echo "Fetching users's token"

            ibmcloud config --check-version false

            ibmcloud login -a $API_ENDPOINT -r $TOOLCHAIN_REGION --apikey
            $API_KEY

            export IBM_CLOUD_BEARER=$(ibmcloud iam oauth-tokens --output JSON |
            jq -r '.iam_token' | awk '{ print $2 }')


            echo "Fetching service urls for user's data"

            HTTP_RESPONSE=$(curl --silent --write-out "HTTPSTATUS:%{http_code}"
            \
              -X GET "${OTC_BROKER_BASE_URL}/globalauth/toolchainids/${TOOLCHAIN_ID}" \
              --header "Authorization: Bearer ${IBM_CLOUD_BEARER}")
            HTTP_STATUS=$(echo $HTTP_RESPONSE | tr -d '\n' | sed -e
            's/.*HTTPSTATUS://')


            if [ "$HTTP_STATUS" -eq 401 -o "$HTTP_STATUS" -eq 403 ]; then
              echo ""
              echo "Error authenticating user for toolchain_id: ${TOOLCHAIN_ID}"
              echo "Please verify the Devops Insights card has been added to your toolchain and the api-key has access."
              exit 1
            fi


            if [ "$HTTP_STATUS" -ne 200 ]; then
              echo ""
              echo "Error! Please try again."
              exit 1
            fi


            HTTP_BODY=$(echo $HTTP_RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')

            gitsecureUrl=$(echo ${HTTP_BODY} | jq -r '.service_urls.gitsecure')


            if [ -z "$gitsecureUrl" -o "$gitsecureUrl" = "null" ]; then
              echo ""
              echo "Error IBM Code Risk Analyzer is not supported in ${REGION_ID}"
              exit 1
            fi


            /usr/local/bin/deploy-analytic \
              -giturl "$(params.repository)" \
              -gitbranch "$(params.revision)" \
              -repodir $REPO_DIR_PATH \
              -apiservice "${gitsecureUrl}" \
              -runid "$PIPELINE_RUN_ID" \
              -commitid "$(params.commit-id)" \
              -results_status "$(results.status.path)" \
              -results_evidence "./gitsecure-cis-results.json" \
              -toolchainid "${TOOLCHAIN_ID}" \
              -comment_md "./gitsecure-cis-comment.md"

            echo -n "gitsecure-cis-results.json" >
            $(results.evidence-store.path)

            echo "COMMENT_FP=./gitsecure-cis-comment.md" >>
            /steps/next-step-env.properties
        volumeMounts:
          - mountPath: /config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
      - name: fetch-git-information
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: REPOSITORY
            value: $(params.repository)
          - name: API_ENDPOINT
            value: $(params.ibmcloud-api)
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.ibmcloud-apikey-secret-key)
                optional: true
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail

            if [ "$PIPELINE_DEBUG" == "1" ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi

            TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')

            REGION_ID=$(jq -r '.region_id' /cd-config/toolchain.json)

            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################

            if [[ "$REPOSITORY" != *.git ]]; then
              echo "Adding .git suffix to Repository URL"
              REPOSITORY="${REPOSITORY}.git"
            fi

            GIT_SERVICE_INSTANCE_ID=$(jq -r --arg git_repo "$REPOSITORY"
            '.services[] | select (.parameters.repo_url==$git_repo) |
            .instance_id' /cd-config/toolchain.json)

            if [ -z "$GIT_SERVICE_INSTANCE_ID" ]; then
              echo "No Git integration (repository url: $REPOSITORY) found in the toolchain"
              exit 1
            fi

            GIT_SERVICE_TYPE=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .service_id'
            /cd-config/toolchain.json)

            if [ "$GIT_SERVICE_TYPE" == "github" ]; then
              GIT_AUTH_USER="x-oauth-basic"
            elif [ "$GIT_SERVICE_TYPE" == "githubpublic" ]; then
              GIT_AUTH_USER="x-oauth-basic"
            elif [ "$GIT_SERVICE_TYPE" == "hostedgit" ]; then
              GIT_AUTH_USER="oauth2"
            elif [ "$GIT_SERVICE_TYPE" == "gitlab" ]; then
              GIT_AUTH_USER="oauth2"
            elif [ "$GIT_SERVICE_TYPE" == "bitbucketgit" ]; then
              GIT_AUTH_USER="x-token-auth"
            else
              GIT_AUTH_USER="x-token-auth"
            fi;

            GIT_TOKEN="$(params.git-access-token)"

            if [ -z "$GIT_TOKEN" ]; then
              if [[ "$REGION_ID" == *"ys1"* ]]; then
                API_ENDPOINT="https://test.cloud.ibm.com"
                echo "targeting ibm cloud @ ${API_ENDPOINT}"
              fi
              echo "Fetching token for $REPOSITORY"
              ibmcloud config --check-version false
              ibmcloud login -a $API_ENDPOINT -r $TOOLCHAIN_REGION --apikey $API_KEY
              if [ "$(params.resource-group)" ]; then
                ibmcloud target -g $(params.resource-group)
              fi
              TOKEN=$(ibmcloud iam oauth-tokens --output JSON | jq -r '.iam_token')
              GIT_TOKEN_URL=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.token_url' /cd-config/toolchain.json)
              # GIT_TOKEN_URL is like https://otc-github-consolidated-broker.us-south.devops.cloud.ibm.com/github/token?git_id=github
              # as there is already an url param git_id, just put the additional ones using &
              echo "Doing cURL to ${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
              curl -s -o /steps/github_token_result.json -X GET -H "Accept: application/json" -H "Authorization: $TOKEN" "${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
              if jq -e '.access_token' /steps/github_token_result.json > /dev/null 2>&1; then
                GIT_TOKEN=$(jq -r '.access_token' /steps/github_token_result.json)
                echo "Access token found for the Git integration (repository url: $REPOSITORY)"
              else
                echo "No access token found for the Git integration (repository url: $REPOSITORY)"
                cat /steps/github_token_result.json
                exit 1
              fi
            else
              echo "Using git Access Token provided"
            fi

            GIT_API_ROOT_URL=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .parameters.api_root_url'
            /cd-config/toolchain.json)

            GIT_OWNER_ID=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .parameters.owner_id'
            /cd-config/toolchain.json)

            GIT_REPO_NAME=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .parameters.repo_name'
            /cd-config/toolchain.json)

            GIT_ID=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select
            (.parameters.repo_url==$git_repo) | .parameters.git_id'
            /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')

            echo "GIT_REPOSITORY=$REPOSITORY" >> /steps/next-step-env.properties

            echo "GIT_AUTH_USER=$GIT_AUTH_USER" >>
            /steps/next-step-env.properties

            echo "GIT_TOKEN=$GIT_TOKEN" >> /steps/next-step-env.properties

            echo "GIT_SERVICE_TYPE=$GIT_SERVICE_TYPE" >>
            /steps/next-step-env.properties

            echo "GIT_ID=$GIT_ID" >> /steps/next-step-env.properties

            echo "GIT_API_ROOT_URL=$GIT_API_ROOT_URL" >>
            /steps/next-step-env.properties

            echo "GIT_OWNER_ID=$GIT_OWNER_ID" >> /steps/next-step-env.properties

            echo "GIT_REPO_NAME=$GIT_REPO_NAME" >>
            /steps/next-step-env.properties

            echo "TOOLCHAIN_REGION=$TOOLCHAIN_REGION" >>
            /steps/next-step-env.properties

            if [ "$PIPELINE_DEBUG" == "1" ]; then
              cat /steps/next-step-env.properties
            fi
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
      - name: comment-editor
        image: 'icr.io/continuous-delivery/cra-comm-editor:main.1260'
        imagePullPolicy: Always
        workingDir: /artifacts
        command:
          - /bin/sh
          - '-c'
        args:
          - |
            #!/bin/sh
            source /steps/next-step-env.properties

            /usr/local/bin/comm-editor \
              -repo-url "$(params.repository)" \
              -pr-url "$(params.pr-url)" \
              -token "$GIT_TOKEN" \
              -comment-fp "$COMMENT_FP" \
              -project-id "$(params.project-id)" \
              -scm-type "$(params.scm-type)"
        volumeMounts:
          - mountPath: /steps
            name: steps-volume
    workspaces:
      - name: artifacts
        mountPath: /artifacts
      - name: secrets
        mountPath: /secrets
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: secrets
        secret:
          secretName: $(params.continuous-delivery-context-secret)
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: cra-comm-editor
  spec:
    params:
      - name: repository
        description: the git repo url
      - name: pr-url
        description: merge request url
        default: ''
      - name: project-id
        description: project id
        default: ''
      - name: comment-fp
        description: comments filepath
      - name: scm-type
        description: 'source code type used (github, github-ent, gitlab)'
    steps:
      - name: comm-editor
        image: 'icr.io/continuous-delivery/cra-comm-editor:main.1260'
        imagePullPolicy: Always
        workingDir: /artifacts
        command:
          - /bin/sh
          - '-c'
        args:
          - |
            #!/bin/sh
            source /steps/next-step-env.properties

            /usr/local/bin/comm-editor \
              -repo-url "$(params.repository)" \
              -pr-url "$(params.pr-url)" \
              -token "$GIT_TOKEN" \
              -user "$GIT_USER" \
              -comment-fp "$(params.comment-fp)" \
              -project-id "$(params.project-id)" \
              -scm-type "$(params.scm-type)"
    workspaces:
      - name: artifacts
        mountPath: /artifacts
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: cra-discovery
  spec:
    params:
      - name: repository
        description: the git repo
      - name: revision
        description: the revision
        default: master
      - name: commit-id
        description: git commit id
      - name: commit-timestamp
        description: git commit timestamp
      - name: directory-name
        description: directory name where the repository is cloned
      - name: pipeline-debug
        description: toggles debug mode for the pipeline
        default: '0'
      - name: continuous-delivery-context-secret
        description: Reference name for the secret resource
        default: secure-properties
      - name: ibmcloud-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud
        default: apikey
      - name: continuous-delivery-context-environment
        description: >-
          Name of the configmap containing the continuous delivery pipeline
          context environment properties
        default: environment-properties
    results:
      - name: status
        description: 'status of discovery task, possible value are-success|failure'
    stepTemplate:
      env:
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: discovery
        image: 'icr.io/continuous-delivery/cra-discovery:main.1278'
        env:
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.ibmcloud-apikey-secret-key)
                optional: true
          - name: DOCKER_CONFIG
            value: /artifacts
        imagePullPolicy: Always
        workingDir: /artifacts
        command:
          - /bin/sh
          - '-c'
        args:
          - >
            #!/bin/sh

            if [ "$PIPELINE_DEBUG" = "1" ]; then
              pwd
              env
              trap env EXIT
              set -x +e
            fi


            REPO_DIR_PATH="/artifacts/$(params.directory-name)"


            TOOLCHAIN_REGION=$(cat /config/toolchain.json | jq -r '.region_id' |
            awk -F: '{print $3}')

            TOOLCHAIN_ID=$(cat /config/toolchain.json | jq -r '.toolchain_guid')

            REGION_ID=$(cat /config/toolchain.json | jq -r '.region_id')


            API_ENDPOINT="https://cloud.ibm.com"

            OTC_BROKER_BASE_URL="https://otcbroker.devopsinsights.cloud.ibm.com"

            if echo "${REGION_ID}" | grep -q "ys1"; then
              OTC_BROKER_BASE_URL="https://otcbroker.devopsinsights.dev.cloud.ibm.com"
              API_ENDPOINT="https://test.cloud.ibm.com"
              echo "targeting otc broker @ ${OTC_BROKER_BASE_URL}"
              echo "targeting ibm cloud @ ${API_ENDPOINT}"
            fi


            echo "Fetching users's token"

            ibmcloud config --check-version false

            ibmcloud login -a $API_ENDPOINT -r $TOOLCHAIN_REGION --apikey
            $API_KEY

            export IBM_CLOUD_BEARER=$(ibmcloud iam oauth-tokens --output JSON |
            jq -r '.iam_token' | awk '{ print $2 }')


            echo "Fetching service urls for user's data"

            HTTP_RESPONSE=$(curl --silent --write-out "HTTPSTATUS:%{http_code}"
            \
              -X GET "${OTC_BROKER_BASE_URL}/globalauth/toolchainids/${TOOLCHAIN_ID}" \
              --header "Authorization: Bearer ${IBM_CLOUD_BEARER}")
            HTTP_STATUS=$(echo $HTTP_RESPONSE | tr -d '\n' | sed -e
            's/.*HTTPSTATUS://')


            if [ "$HTTP_STATUS" -eq 401 -o "$HTTP_STATUS" -eq 403 ]; then
              echo ""
              echo "Error authenticating user for toolchain_id: ${TOOLCHAIN_ID}"
              echo "Please verify the Devops Insights card has been added to your toolchain and the api-key has access."
              exit 1
            fi


            if [ "$HTTP_STATUS" -ne 200 ]; then
              echo ""
              echo "Error! Please try again."
              exit 1
            fi


            HTTP_BODY=$(echo $HTTP_RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')

            gitsecureUrl=$(echo ${HTTP_BODY} | jq -r '.service_urls.gitsecure')


            if [ -z "$gitsecureUrl" -o "$gitsecureUrl" = "null" ]; then
              echo ""
              echo "Error IBM Code Risk Analyzer is not supported in ${REGION_ID}"
              exit 1
            fi


            # create a dry-run k8s secret of type docker-registry to obtain 

            # the pull secrets for the base image used in the dockerfile

            # this is optional, but sometimes useful, for example when using

            # UBI images from RedHat
             
            if [ -f "/properties/baseimage-auth-user" ] \
              && [ -f "/secrets/baseimage-auth-password" ] \
              && [ -f "/properties/baseimage-auth-host" ]; then
              echo "Adding pull secrets to access base image registry $(cat /properties/baseimage-auth-host)"
              kubectl create secret --dry-run=client --output=json \
                docker-registry registry-dockerconfig-secret \
                --docker-username="$(cat /properties/baseimage-auth-user)" \
                --docker-password="$(cat /secrets/baseimage-auth-password)" \
                --docker-server="$(cat /properties/baseimage-auth-host)" \
                --docker-email="$(cat /properties/baseimage-auth-email)" | \
                jq -r '.data[".dockerconfigjson"]' | base64 -d > config.json
            fi


            /usr/local/bin/discovery \
              -giturl "$(params.repository)" \
              -gitbranch "$(params.revision)" \
              -repodir $REPO_DIR_PATH  \
              -rigapi "${gitsecureUrl}" \
              -commitid "$(params.commit-id)" \
              -commitTimestamp "$(params.commit-timestamp)" \
              -toolchainid "${TOOLCHAIN_ID}"
        volumeMounts:
          - mountPath: /config
            name: config-volume
          - mountPath: /var/run/
            name: docker-socket
          - mountPath: /properties
            name: environment-properties
          - mountPath: /secrets
            name: secure-properties
    sidecars:
      - image: 'docker:19.03-dind'
        name: server
        securityContext:
          privileged: true
        env:
          - name: DOCKER_BUILDKIT
            value: 1
          - name: DOCKER_TLS_CERTDIR
            value: /certs
        volumeMounts:
          - mountPath: /var/run/
            name: docker-socket
        readinessProbe:
          periodSeconds: 1
          exec:
            command:
              - ls
              - /certs/client/ca.pem
    workspaces:
      - name: artifacts
        mountPath: /artifacts
    volumes:
      - name: config-volume
        configMap:
          name: toolchain
      - name: docker-socket
        emptyDir: {}
      - name: environment-properties
        configMap:
          name: $(params.continuous-delivery-context-environment)
      - name: secure-properties
        secret:
          secretName: $(params.continuous-delivery-context-secret)
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: cra-terraform-scan
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: repository
        description: the git repo
      - name: revision
        description: the revision
        default: master
      - name: tf-dir
        description: the directory where the terraform main entry file is found
        default: ''
      - name: ibmcloud-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud
        default: apikey
      - name: continuous-delivery-context-secret
        description: Reference name for the secret resource
        default: secure-properties
      - name: directory-name
        description: directory name where the repository is cloned
      - name: pipeline-debug
        description: toggles debug mode for the pipeline
        default: '0'
      - name: policy-config-json
        description: Configure policies to control thresholds
        default: ''
      - name: pr-url
        description: pull request html url
        default: ''
      - name: project-id
        description: 'for gitlab repository, specify project-id'
        default: ''
      - name: scm-type
        description: 'source code type used (github, github-ent, gitlab)'
        default: github-ent
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: git-access-token
        description: >
          (optional) token to access the git repository. If this token is
          provided, there will not be an attempt

          to use the git token obtained from the authorization flow when adding
          the git integration in the toolchain
        default: ''
      - name: tf-var-file
        description: (optional) terraform var-file
        default: ''
    results:
      - name: status
        description: 'status of deployment analyzer task, possible value are- success|failed'
      - name: evidence-store
        description: filepath to store deployment analyzer task evidence
    stepTemplate:
      env:
        - name: PIPELINE_RUN_ID
          valueFrom:
            fieldRef:
              fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
        - name: VAR_FILE
          value: $(params.tf-var-file)
    steps:
      - name: terraform-compliance
        image: 'icr.io/continuous-delivery/cra-terraform:release.1455'
        envFrom:
          - configMapRef:
              name: environment-properties
          - secretRef:
              name: secure-properties
        env:
          - name: REPOSITORY
            value: $(params.repository)
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.ibmcloud-apikey-secret-key)
                optional: true
        imagePullPolicy: Always
        securityContext:
          runAsUser: root
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            if [[ "$PIPELINE_DEBUG" == "1" ]]; then
              pwd
              ls /artifacts/
              env
              trap env EXIT
              set -x +e           
            fi


            REPO_DIR_PATH="/artifacts/$(params.directory-name)"

            TOOLCHAIN_CONFIG=$(cat /config/toolchain.json)

            TOOLCHAIN_REGION=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.region_id' |
            awk -F: '{print $3}')

            TOOLCHAIN_ID=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.toolchain_guid')

            REGION_ID=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.region_id')

            API_ENDPOINT="https://cloud.ibm.com"

            OTC_BROKER_BASE_URL="https://otcbroker.devopsinsights.cloud.ibm.com"

            if echo "${REGION_ID}" | grep -q "ys1"; then
              OTC_BROKER_BASE_URL="https://otcbroker.devopsinsights.dev.cloud.ibm.com"
              API_ENDPOINT="https://test.cloud.ibm.com"
              echo "targeting otc broker @ ${OTC_BROKER_BASE_URL}"
              echo "targeting ibm cloud @ ${API_ENDPOINT}"
            fi

            echo "Fetching users's token"

            ibmcloud config --check-version false

            ibmcloud login -a $API_ENDPOINT -r $TOOLCHAIN_REGION --apikey
            $API_KEY

            export IBM_CLOUD_BEARER=$(ibmcloud iam oauth-tokens --output JSON |
            jq -r '.iam_token' | awk '{ print $2 }')

            echo "Fetching service urls for user's data"

            HTTP_RESPONSE=$(curl --silent --write-out "HTTPSTATUS:%{http_code}"
            \
              -X GET "${OTC_BROKER_BASE_URL}/globalauth/toolchainids/${TOOLCHAIN_ID}" \
              --header "Authorization: Bearer ${IBM_CLOUD_BEARER}")
            HTTP_STATUS=$(echo $HTTP_RESPONSE | tr -d '\n' | sed -e
            's/.*HTTPSTATUS://')

            if [[ "$HTTP_STATUS" -eq 401 || "$HTTP_STATUS" -eq 403 ]]; then
              echo ""
              echo "Error authenticating user for toolchain_id: ${TOOLCHAIN_ID}"
              echo "Please verify the Devops Insights card has been added to your toolchain and the api-key has access."
              exit 1
            fi

            if [[ "$HTTP_STATUS" -ne 200 ]]; then
              echo ""
              echo "Error! Please try again."
              exit 1
            fi

            HTTP_BODY=$(echo $HTTP_RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')

            gitsecureUrl=$(echo ${HTTP_BODY} | jq -r '.service_urls.gitsecure')

            if [[ -z "$gitsecureUrl" || "$gitsecureUrl" = "null" ]]; then
              echo ""
              echo "Error IBM Code Risk Analyzer is not supported in ${REGION_ID}"
              exit 1
            fi


            echo "Running terraform compliance task"                    

            if [[ $PIPELINE_DEBUG == 1 ]];
              then
                ls $REPO_DIR_PATH
            fi

            result="failed"

            LOG_LEVEL="info"


            if [[ "$(params.policy-config-json)" == "" ]]; 

            then
              node /usr/src/index.js --git_token "NA" --repository $(params.repository) --gitClonedDir $REPO_DIR_PATH --INPUT_TF_DIR $(params.tf-dir) --revision $(params.revision) --commitid "NA" --pipelinerunid $PIPELINE_RUN_ID --prnumber "NA" --LOG_LEVEL $LOG_LEVEL --silent 1
            else
              node /usr/src/index.js --policyConfig $(params.policy-config-json) --git_token "NA" --repository $(params.repository) --gitClonedDir $REPO_DIR_PATH --INPUT_TF_DIR $(params.tf-dir) --revision $(params.revision) --commitid "NA" --pipelinerunid $PIPELINE_RUN_ID --prnumber "NA" --LOG_LEVEL $LOG_LEVEL --silent 1
            fi


            if [ $? == 0 ]; then export result="success"; fi          


            if [[ $PIPELINE_DEBUG == 1 ]];
              then
                cat /usr/policies/ibm/terraform-config.rego
                echo $result
                cat result.json
            fi


            echo -n $result > "$(results.status.path)"                    

            echo -n "deploymant-analyzer.json" > $(results.evidence-store.path)


            mv ./da-terraform-check-comment.md
            /artifacts/da-terraform-check-comment.md

            echo "COMMENT_FP=./da-terraform-check-comment.md" >>
            /steps/next-step-env.properties
        volumeMounts:
          - mountPath: /config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
      - name: fetch-git-information
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: REPOSITORY
            value: $(params.repository)
          - name: API_ENDPOINT
            value: $(params.ibmcloud-api)
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.ibmcloud-apikey-secret-key)
                optional: true
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail

            if [ "$PIPELINE_DEBUG" == "1" ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi

            TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')

            REGION_ID=$(jq -r '.region_id' /cd-config/toolchain.json)

            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################

            if [[ "$REPOSITORY" != *.git ]]; then
              echo "Adding .git suffix to Repository URL"
              REPOSITORY="${REPOSITORY}.git"
            fi

            GIT_SERVICE_INSTANCE_ID=$(jq -r --arg git_repo "$REPOSITORY"
            '.services[] | select (.parameters.repo_url==$git_repo) |
            .instance_id' /cd-config/toolchain.json)

            if [ -z "$GIT_SERVICE_INSTANCE_ID" ]; then
              echo "No Git integration (repository url: $REPOSITORY) found in the toolchain"
              exit 1
            fi

            GIT_SERVICE_TYPE=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .service_id'
            /cd-config/toolchain.json)

            if [ "$GIT_SERVICE_TYPE" == "github" ]; then
              GIT_AUTH_USER="x-oauth-basic"
            elif [ "$GIT_SERVICE_TYPE" == "githubpublic" ]; then
              GIT_AUTH_USER="x-oauth-basic"
            elif [ "$GIT_SERVICE_TYPE" == "hostedgit" ]; then
              GIT_AUTH_USER="oauth2"
            elif [ "$GIT_SERVICE_TYPE" == "gitlab" ]; then
              GIT_AUTH_USER="oauth2"
            elif [ "$GIT_SERVICE_TYPE" == "bitbucketgit" ]; then
              GIT_AUTH_USER="x-token-auth"
            else
              GIT_AUTH_USER="x-token-auth"
            fi;

            GIT_TOKEN="$(params.git-access-token)"

            if [ -z "$GIT_TOKEN" ]; then
              if [[ "$REGION_ID" == *"ys1"* ]]; then
                API_ENDPOINT="https://test.cloud.ibm.com"
                echo "targeting ibm cloud @ ${API_ENDPOINT}"
              fi
              echo "Fetching token for $REPOSITORY"
              ibmcloud config --check-version false
              ibmcloud login -a $API_ENDPOINT -r $TOOLCHAIN_REGION --apikey $API_KEY
              if [ "$(params.resource-group)" ]; then
                ibmcloud target -g $(params.resource-group)
              fi
              TOKEN=$(ibmcloud iam oauth-tokens --output JSON | jq -r '.iam_token')
              GIT_TOKEN_URL=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.token_url' /cd-config/toolchain.json)
              # GIT_TOKEN_URL is like https://otc-github-consolidated-broker.us-south.devops.cloud.ibm.com/github/token?git_id=github
              # as there is already an url param git_id, just put the additional ones using &
              echo "Doing cURL to ${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
              curl -s -o /steps/github_token_result.json -X GET -H "Accept: application/json" -H "Authorization: $TOKEN" "${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
              if jq -e '.access_token' /steps/github_token_result.json > /dev/null 2>&1; then
                GIT_TOKEN=$(jq -r '.access_token' /steps/github_token_result.json)
                echo "Access token found for the Git integration (repository url: $REPOSITORY)"
              else
                echo "No access token found for the Git integration (repository url: $REPOSITORY)"
                cat /steps/github_token_result.json
                exit 1
              fi
            else
              echo "Using git Access Token provided"
            fi

            GIT_API_ROOT_URL=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .parameters.api_root_url'
            /cd-config/toolchain.json)

            GIT_OWNER_ID=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .parameters.owner_id'
            /cd-config/toolchain.json)

            GIT_REPO_NAME=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .parameters.repo_name'
            /cd-config/toolchain.json)

            GIT_ID=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select
            (.parameters.repo_url==$git_repo) | .parameters.git_id'
            /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')

            echo "GIT_REPOSITORY=$REPOSITORY" >> /steps/next-step-env.properties

            echo "GIT_AUTH_USER=$GIT_AUTH_USER" >>
            /steps/next-step-env.properties

            echo "GIT_TOKEN=$GIT_TOKEN" >> /steps/next-step-env.properties

            echo "GIT_SERVICE_TYPE=$GIT_SERVICE_TYPE" >>
            /steps/next-step-env.properties

            echo "GIT_ID=$GIT_ID" >> /steps/next-step-env.properties

            echo "GIT_API_ROOT_URL=$GIT_API_ROOT_URL" >>
            /steps/next-step-env.properties

            echo "GIT_OWNER_ID=$GIT_OWNER_ID" >> /steps/next-step-env.properties

            echo "GIT_REPO_NAME=$GIT_REPO_NAME" >>
            /steps/next-step-env.properties

            echo "TOOLCHAIN_REGION=$TOOLCHAIN_REGION" >>
            /steps/next-step-env.properties

            if [ "$PIPELINE_DEBUG" == "1" ]; then
              cat /steps/next-step-env.properties
            fi
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
      - name: comment-editor
        image: 'icr.io/continuous-delivery/cra-comm-editor:main.1260'
        imagePullPolicy: Always
        workingDir: /artifacts
        command:
          - /bin/sh
          - '-c'
        args:
          - |
            #!/bin/sh
            source /steps/next-step-env.properties

            /usr/local/bin/comm-editor \
              -repo-url "$(params.repository)" \
              -pr-url "$(params.pr-url)" \
              -token "$GIT_TOKEN" \
              -comment-fp "$COMMENT_FP" \
              -project-id "$(params.project-id)" \
              -scm-type "$(params.scm-type)"
        volumeMounts:
          - mountPath: /steps
            name: steps-volume
    workspaces:
      - name: artifacts
        mountPath: /artifacts
      - name: secrets
        mountPath: /secrets
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: secrets
        secret:
          secretName: $(params.continuous-delivery-context-secret)
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: cra-vulnerability-remediation
  spec:
    params:
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: repository
        description: the git repo
      - name: revision
        description: the revision
        default: master
      - name: pr-url
        description: pull request url
        default: ''
      - name: commit-id
        description: git commit id
      - name: ibmcloud-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to login to
          ibmcloud
        default: apikey
      - name: continuous-delivery-context-secret
        description: Reference name for the secret resource
        default: secure-properties
      - name: git-access-token
        description: >
          (optional) token to access the git repository. If this token is
          provided, there will not be an attempt

          to use the git token obtained from the authorization flow when adding
          the git integration in the toolchain
        default: ''
      - name: resource-group
        description: target resource group (name or id) for the ibmcloud login operation
        default: ''
      - name: project-id
        description: 'for gitlab repository, specify project-id'
        default: ''
      - name: scm-type
        description: 'source code type used (github, github-ent, gitlab)'
        default: github-ent
      - name: pipeline-debug
        description: toggles debug mode for the pipeline
        default: '0'
    results:
      - name: status
        description: 'status of vulnerability task, possible value are-success|failure'
      - name: evidence-store
        description: filepath to store vulnerability task evidence
    stepTemplate:
      env:
        - name: PIPELINE_RUN_ID
          valueFrom:
            fieldRef:
              fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: remediation
        image: 'icr.io/continuous-delivery/cra-vulnerability:main.1266'
        env:
          - name: REPOSITORY
            value: $(params.repository)
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.ibmcloud-apikey-secret-key)
                optional: true
        imagePullPolicy: Always
        workingDir: /artifacts
        command:
          - /bin/sh
          - '-c'
        args:
          - >
            #!/bin/sh

            if [ "$PIPELINE_DEBUG" == "1" ]; then
              pwd
              env
              trap env EXIT
              set -x +e
            fi


            TOOLCHAIN_CONFIG=$(cat /config/toolchain.json)

            TOOLCHAIN_REGION=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.region_id' |
            awk -F: '{print $3}')

            TOOLCHAIN_ID=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.toolchain_guid')

            REGION_ID=$(echo ${TOOLCHAIN_CONFIG} | jq -r '.region_id')


            API_ENDPOINT="https://cloud.ibm.com"

            OTC_BROKER_BASE_URL="https://otcbroker.devopsinsights.cloud.ibm.com"

            if echo "${REGION_ID}" | grep -q "ys1"; then
              OTC_BROKER_BASE_URL="https://otcbroker.devopsinsights.dev.cloud.ibm.com"
              API_ENDPOINT="https://test.cloud.ibm.com"
              echo "targeting otc broker @ ${OTC_BROKER_BASE_URL}"
              echo "targeting ibm cloud @ ${API_ENDPOINT}"
            fi


            echo "Fetching users's token"

            ibmcloud config --check-version false

            ibmcloud login -a $API_ENDPOINT -r $TOOLCHAIN_REGION --apikey
            $API_KEY

            export IBM_CLOUD_BEARER=$(ibmcloud iam oauth-tokens --output JSON |
            jq -r '.iam_token' | awk '{ print $2 }')


            echo "Fetching service urls for user's data"

            HTTP_RESPONSE=$(curl --silent --write-out "HTTPSTATUS:%{http_code}"
            \
              -X GET "${OTC_BROKER_BASE_URL}/globalauth/toolchainids/${TOOLCHAIN_ID}" \
              --header "Authorization: Bearer ${IBM_CLOUD_BEARER}")
            HTTP_STATUS=$(echo $HTTP_RESPONSE | tr -d '\n' | sed -e
            's/.*HTTPSTATUS://')


            if [ "$HTTP_STATUS" -eq 401 -o "$HTTP_STATUS" -eq 403 ]; then
              echo ""
              echo "Error authenticating user for toolchain_id: ${TOOLCHAIN_ID}"
              echo "Please verify the Devops Insights card has been added to your toolchain and the api-key has access."
              exit 1
            fi


            if [ "$HTTP_STATUS" -ne 200 ]; then
              echo ""
              echo "Error! Please try again."
              exit 1
            fi


            HTTP_BODY=$(echo $HTTP_RESPONSE | sed -e 's/HTTPSTATUS\:.*//g')

            gitsecureUrl=$(echo ${HTTP_BODY} | jq -r '.service_urls.gitsecure')


            if [ -z "$gitsecureUrl" -o "$gitsecureUrl" = "null" ]; then
              echo ""
              echo "Error IBM Code Risk Analyzer is not supported in ${REGION_ID}"
              exit 1
            fi


            vcuratorUrl=$(echo ${HTTP_BODY} | jq -r '.service_urls.vcurator')


            if [ -z "$vcuratorUrl" -o "$vcuratorUrl" = "null" ]; then
              echo "Error fetching the vcurator url."
              exit 1
            fi


            /gitsecure/vulnerability-task \
              -giturl "$(params.repository)" \
              -gitbranch "$(params.revision)" \
              -rigserviceapi "${gitsecureUrl}" \
              -runid "$PIPELINE_RUN_ID" \
              -commitid "$(params.commit-id)" \
              -comment_md "./comment_md.json" \
              -security_advisory_svc "${vcuratorUrl}" \
              -results_status "$(results.status.path)" \
              -results_evidence "./gitsecure-vulnerability-results.json" \
              -toolchainid "${TOOLCHAIN_ID}" \
              -comment_md "./vulnerability-comment.md"

            echo -n "gitsecure-vulnerability-results.json" >
            $(results.evidence-store.path)

            echo "COMMENT_FP=./vulnerability-comment.md" >>
            /steps/next-step-env.properties
        volumeMounts:
          - mountPath: /config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
      - name: fetch-git-information
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: REPOSITORY
            value: $(params.repository)
          - name: API_ENDPOINT
            value: $(params.ibmcloud-api)
          - name: API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.ibmcloud-apikey-secret-key)
                optional: true
        command:
          - /bin/bash
          - '-c'
        args:
          - >
            set -e -o pipefail

            if [ "$PIPELINE_DEBUG" == "1" ]; then
                pwd
                env
                trap env EXIT
                set -x
            fi

            TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')

            REGION_ID=$(jq -r '.region_id' /cd-config/toolchain.json)

            ##########################################################################

            # Setting HOME explicitly to have ibmcloud plugins available

            # doing the export rather than env definition is a workaround

            # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

            export HOME="/root"

            ##########################################################################

            if [[ "$REPOSITORY" != *.git ]]; then
              echo "Adding .git suffix to Repository URL"
              REPOSITORY="${REPOSITORY}.git"
            fi

            GIT_SERVICE_INSTANCE_ID=$(jq -r --arg git_repo "$REPOSITORY"
            '.services[] | select (.parameters.repo_url==$git_repo) |
            .instance_id' /cd-config/toolchain.json)

            if [ -z "$GIT_SERVICE_INSTANCE_ID" ]; then
              echo "No Git integration (repository url: $REPOSITORY) found in the toolchain"
              exit 1
            fi

            GIT_SERVICE_TYPE=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .service_id'
            /cd-config/toolchain.json)

            if [ "$GIT_SERVICE_TYPE" == "github" ]; then
              GIT_AUTH_USER="x-oauth-basic"
            elif [ "$GIT_SERVICE_TYPE" == "githubpublic" ]; then
              GIT_AUTH_USER="x-oauth-basic"
            elif [ "$GIT_SERVICE_TYPE" == "hostedgit" ]; then
              GIT_AUTH_USER="oauth2"
            elif [ "$GIT_SERVICE_TYPE" == "gitlab" ]; then
              GIT_AUTH_USER="oauth2"
            elif [ "$GIT_SERVICE_TYPE" == "bitbucketgit" ]; then
              GIT_AUTH_USER="x-token-auth"
            else
              GIT_AUTH_USER="x-token-auth"
            fi;

            GIT_TOKEN="$(params.git-access-token)"

            if [ -z "$GIT_TOKEN" ]; then
              if [[ "$REGION_ID" == *"ys1"* ]]; then
                API_ENDPOINT="https://test.cloud.ibm.com"
                echo "targeting ibm cloud @ ${API_ENDPOINT}"
              fi
              echo "Fetching token for $REPOSITORY"
              ibmcloud config --check-version false
              ibmcloud login -a $API_ENDPOINT -r $TOOLCHAIN_REGION --apikey $API_KEY
              if [ "$(params.resource-group)" ]; then
                ibmcloud target -g $(params.resource-group)
              fi
              TOKEN=$(ibmcloud iam oauth-tokens --output JSON | jq -r '.iam_token')
              GIT_TOKEN_URL=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select (.parameters.repo_url==$git_repo) | .parameters.token_url' /cd-config/toolchain.json)
              # GIT_TOKEN_URL is like https://otc-github-consolidated-broker.us-south.devops.cloud.ibm.com/github/token?git_id=github
              # as there is already an url param git_id, just put the additional ones using &
              echo "Doing cURL to ${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
              curl -s -o /steps/github_token_result.json -X GET -H "Accept: application/json" -H "Authorization: $TOKEN" "${GIT_TOKEN_URL}&toolchain_id=${TOOLCHAIN_ID}&service_instance_id=${GIT_SERVICE_INSTANCE_ID}&repo_url=${REPOSITORY}"
              if jq -e '.access_token' /steps/github_token_result.json > /dev/null 2>&1; then
                GIT_TOKEN=$(jq -r '.access_token' /steps/github_token_result.json)
                echo "Access token found for the Git integration (repository url: $REPOSITORY)"
              else
                echo "No access token found for the Git integration (repository url: $REPOSITORY)"
                cat /steps/github_token_result.json
                exit 1
              fi
            else
              echo "Using git Access Token provided"
            fi

            GIT_API_ROOT_URL=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .parameters.api_root_url'
            /cd-config/toolchain.json)

            GIT_OWNER_ID=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .parameters.owner_id'
            /cd-config/toolchain.json)

            GIT_REPO_NAME=$(jq -r --arg git_repo "$REPOSITORY" '.services[] |
            select (.parameters.repo_url==$git_repo) | .parameters.repo_name'
            /cd-config/toolchain.json)

            GIT_ID=$(jq -r --arg git_repo "$REPOSITORY" '.services[] | select
            (.parameters.repo_url==$git_repo) | .parameters.git_id'
            /cd-config/toolchain.json)

            TOOLCHAIN_REGION=$(jq -r '.region_id' /cd-config/toolchain.json |
            awk -F: '{print $3}')

            echo "GIT_REPOSITORY=$REPOSITORY" >> /steps/next-step-env.properties

            echo "GIT_AUTH_USER=$GIT_AUTH_USER" >>
            /steps/next-step-env.properties

            echo "GIT_TOKEN=$GIT_TOKEN" >> /steps/next-step-env.properties

            echo "GIT_SERVICE_TYPE=$GIT_SERVICE_TYPE" >>
            /steps/next-step-env.properties

            echo "GIT_ID=$GIT_ID" >> /steps/next-step-env.properties

            echo "GIT_API_ROOT_URL=$GIT_API_ROOT_URL" >>
            /steps/next-step-env.properties

            echo "GIT_OWNER_ID=$GIT_OWNER_ID" >> /steps/next-step-env.properties

            echo "GIT_REPO_NAME=$GIT_REPO_NAME" >>
            /steps/next-step-env.properties

            echo "TOOLCHAIN_REGION=$TOOLCHAIN_REGION" >>
            /steps/next-step-env.properties


            if [ "$PIPELINE_DEBUG" == "1" ]; then
              cat /steps/next-step-env.properties
            fi
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
      - name: comment-editor
        image: 'icr.io/continuous-delivery/cra-comm-editor:main.1260'
        imagePullPolicy: Always
        workingDir: /artifacts
        command:
          - /bin/sh
          - '-c'
        args:
          - |
            #!/bin/sh
            source /steps/next-step-env.properties

            /usr/local/bin/comm-editor \
              -repo-url "$(params.repository)" \
              -pr-url "$(params.pr-url)" \
              -token "$GIT_TOKEN" \
              -comment-fp "$COMMENT_FP" \
              -project-id "$(params.project-id)" \
              -scm-type "$(params.scm-type)"
        volumeMounts:
          - mountPath: /steps
            name: steps-volume
    workspaces:
      - name: artifacts
        mountPath: /artifacts
      - name: secrets
        mountPath: /secrets
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: secrets
        secret:
          secretName: $(params.continuous-delivery-context-secret)
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: doi-evaluate-gate
  spec:
    params:
      - name: app-name
        description: Logical application name for DevOps Insights
      - name: toolchain-id
        description: >
          Toolchain service instance id.

          Default to the toolchain containing the CD Tekton PipelineRun
          currently executed
        default: ''
      - name: build-number
        description: >-
          Devops Insights build number reference. Default to the CD Tekton
          Pipeline build number
        default: ''
      - name: policy
        description: The name of the policy that the gate uses to make its decision
      - name: force
        description: >-
          indicate if the evaluation gate should be forced or not ("true" |
          "false")
        default: 'true'
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          Name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: toolchain-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to access toolchain
          and DOI instance
        default: toolchain-apikey
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    stepTemplate:
      env:
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: evaluate-gate
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: IBM_CLOUD_API
            value: $(params.ibmcloud-api)
          - name: IBM_CLOUD_API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.toolchain-apikey-secret-key)
                optional: true
          - name: APP_NAME
            value: $(params.app-name)
          - name: TOOLCHAIN_ID
            value: $(params.toolchain-id)
          - name: BUILD_NUMBER
            value: $(params.build-number)
          - name: DEFAULT_BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
        script: >
          #!/bin/bash

          set -e -o pipefail


          if [ $PIPELINE_DEBUG == 1 ]; then
              pwd
              env
              trap env EXIT
              set -x
          fi


          ##########################################################################

          # Setting HOME explicitly to have ibmcloud plugins available

          # doing the export rather than env definition is a workaround

          # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

          export HOME="/root"

          ##########################################################################


          if [ -z "$(params.policy)" ]; then
              echo "No Policy specified. Exiting successully"
              exit 0
          fi


          if [[ "$IBM_CLOUD_API" == *test* ]]; then
            export IBM_CLOUD_DEVOPS_ENV=dev
          fi


          # Default Toolchain ID if needed

          if [ -z "$TOOLCHAIN_ID" ]; then
            TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)
          fi


          # Default build number if needed

          if [ -z "$BUILD_NUMBER" ]; then
            BUILD_NUMBER="$DEFAULT_BUILD_NUMBER"
          fi


          if [ "$(params.force)" == "true" ]; then
            FORCE_DECISION=" --forcedecision"
          else
            FORCE_DECISION=""
          fi


          export TOOLCHAIN_ID=${TOOLCHAIN_ID} # for doi plugin

          ibmcloud login --apikey ${IBM_CLOUD_API_KEY} -a ${IBM_CLOUD_API}
          --no-region

          ibmcloud doi evaluategate --policy "$(params.policy)" --buildnumber
          "${BUILD_NUMBER}" \
            --logicalappname "${APP_NAME}" ${FORCE_DECISION}
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
    volumes:
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: doi-publish-buildrecord
  spec:
    params:
      - name: app-name
        description: Logical application name for DevOps Insights
      - name: toolchain-id
        description: >
          Toolchain service instance id.

          Default to the toolchain containing the CD Tekton PipelineRun
          currently executed
        default: ''
      - name: build-number
        description: >-
          Devops Insights build number reference. Default to the CD Tekton
          Pipeline build number
        default: ''
      - name: build-status
        description: the build status (can be either pass | fail)
        default: pass
      - name: git-repository
        description: The url of the git repository
      - name: git-branch
        description: The repository branch on which the build has been performed
      - name: git-commit
        description: The git commit id
      - name: job-url
        description: >-
          The url to the job's build logs. Default to the CD Tekton PipelineRun
          currently executed
        default: ''
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          Name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: toolchain-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to access toolchain
          and DOI instance
        default: toolchain-apikey
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    results:
      - name: build-number
        description: Devops Insights build number reference used
    stepTemplate:
      env:
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: publish-build-record
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: IBM_CLOUD_API
            value: $(params.ibmcloud-api)
          - name: IBM_CLOUD_API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.toolchain-apikey-secret-key)
                optional: true
          - name: APP_NAME
            value: $(params.app-name)
          - name: TOOLCHAIN_ID
            value: $(params.toolchain-id)
          - name: BUILD_NUMBER
            value: $(params.build-number)
          - name: BUILD_STATUS
            value: $(params.build-status)
          - name: GIT_URL
            value: $(params.git-repository)
          - name: GIT_BRANCH
            value: $(params.git-branch)
          - name: GIT_COMMIT
            value: $(params.git-commit)
          - name: JOB_URL
            value: $(params.job-url)
          - name: PIPELINE_RUN_URL
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-run-url'']'
          - name: DEFAULT_BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
        script: >
          #!/bin/bash

          set -e -o pipefail


          if [ $PIPELINE_DEBUG == 1 ]; then
              pwd
              env
              trap env EXIT
              set -x
          fi


          ##########################################################################

          # Setting HOME explicitly to have ibmcloud plugins available

          # doing the export rather than env definition is a workaround

          # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

          export HOME="/root"

          ##########################################################################

          if [[ "$IBM_CLOUD_API" == *test* ]]; then
            export IBM_CLOUD_DEVOPS_ENV=dev
          fi


          # Default Toolchain ID if needed

          if [ -z "$TOOLCHAIN_ID" ]; then
            TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)
          fi


          # Default Job URL if needed

          if [ -z "$JOB_URL" ]; then
            JOB_URL="$PIPELINE_RUN_URL"
          fi


          # Default build number if needed

          if [ -z "$BUILD_NUMBER" ]; then
            BUILD_NUMBER="$DEFAULT_BUILD_NUMBER"
          fi


          export TOOLCHAIN_ID=${TOOLCHAIN_ID} # for doi plugin

          ibmcloud login --apikey ${IBM_CLOUD_API_KEY} -a ${IBM_CLOUD_API}
          --no-region

          ibmcloud doi publishbuildrecord --logicalappname="${APP_NAME}"
          --buildnumber=${BUILD_NUMBER} \
            --branch=${GIT_BRANCH} --repositoryurl=${GIT_URL} --commitid=${GIT_COMMIT} \
            --status=${BUILD_STATUS} --joburl="$JOB_URL"

          # Record task results

          echo -n "${BUILD_NUMBER}" > $(results.build-number.path)
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
    volumes:
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: doi-publish-deployrecord
  spec:
    params:
      - name: app-name
        description: Logical application name for DevOps Insights
      - name: toolchain-id
        description: >
          Toolchain service instance id.

          Default to the toolchain containing the CD Tekton PipelineRun
          currently executed
        default: ''
      - name: build-number
        description: >-
          Devops Insights build number reference. Default to the CD Tekton
          Pipeline build number
        default: ''
      - name: environment
        description: The environment where the pipeline job deployed the app.
      - name: deploy-status
        description: The deployment status (can be either pass | fail)
        default: pass
      - name: job-url
        description: >-
          The url to the job's deployment logs. Default to the CD Tekton
          PipelineRun currently executed
        default: ''
      - name: app-url
        description: The URL where the deployed app is running
        default: ''
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          Name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: toolchain-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to access toolchain
          and DOI instance
        default: toolchain-apikey
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    stepTemplate:
      env:
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: publish-deployrecord
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: IBM_CLOUD_API
            value: $(params.ibmcloud-api)
          - name: IBM_CLOUD_API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.toolchain-apikey-secret-key)
                optional: true
          - name: APP_NAME
            value: $(params.app-name)
          - name: TOOLCHAIN_ID
            value: $(params.toolchain-id)
          - name: BUILD_NUMBER
            value: $(params.build-number)
          - name: DEPLOY_STATUS
            value: $(params.deploy-status)
          - name: ENVIRONMENT
            value: $(params.environment)
          - name: JOB_URL
            value: $(params.job-url)
          - name: PIPELINE_RUN_URL
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-run-url'']'
          - name: DEFAULT_BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
        workingDir: /artifacts
        script: >
          #!/bin/bash

          set -e -o pipefail


          if [ $PIPELINE_DEBUG == 1 ]; then
              pwd
              env
              trap env EXIT
              set -x
          fi


          ##########################################################################

          # Setting HOME explicitly to have ibmcloud plugins available

          # doing the export rather than env definition is a workaround

          # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

          export HOME="/root"

          ##########################################################################

          if [[ "$IBM_CLOUD_API" == *test* ]]; then
            export IBM_CLOUD_DEVOPS_ENV=dev
          fi


          # Default Toolchain ID if needed

          if [ -z "$TOOLCHAIN_ID" ]; then
            TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)
          fi


          # Default Job URL if needed

          if [ -z "$JOB_URL" ]; then
            JOB_URL="$PIPELINE_RUN_URL"
          fi


          # Default build number if needed

          if [ -z "$BUILD_NUMBER" ]; then
            BUILD_NUMBER="$DEFAULT_BUILD_NUMBER"
          fi


          if [ "$(params.app-url)" ]; then
            APP_URL=" --appurl \"$(params.app-url)\""
          else
            APP_URL=""
          fi


          export TOOLCHAIN_ID=${TOOLCHAIN_ID} # for doi plugin

          ibmcloud login --apikey ${IBM_CLOUD_API_KEY} -a ${IBM_CLOUD_API}
          --no-region

          ibmcloud doi publishdeployrecord --env "${ENVIRONMENT}"
          --status=${DEPLOY_STATUS} --joburl="${JOB_URL}" \
            --buildnumber="${BUILD_NUMBER}" --logicalappname="${APP_NAME}" ${APP_URL}
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
    volumes:
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: doi-publish-testrecord
  spec:
    params:
      - name: app-name
        description: Logical application name for DevOps Insights
      - name: toolchain-id
        description: >
          Toolchain service instance id.

          Default to the toolchain containing the CD Tekton PipelineRun
          currently executed
        default: ''
      - name: build-number
        description: >-
          Devops Insights build number reference. Default to the CD Tekton
          Pipeline build number
        default: ''
      - name: file-locations
        description: Semi-colon separated list of test result file locations
      - name: test-types
        description: Semi-colon separated list of test result types
      - name: environment
        description: >
          Optional, The environment name to associate with the test results.

          This option is ignored for unit tests, code coverage tests, and static
          security scans.
        default: ''
      - name: ibmcloud-api
        description: the ibmcloud api
        default: 'https://cloud.ibm.com'
      - name: continuous-delivery-context-secret
        description: >-
          Name of the secret containing the continuous delivery pipeline context
          secrets
        default: secure-properties
      - name: toolchain-apikey-secret-key
        description: >-
          field in the secret that contains the api key used to access toolchain
          and DOI instance
        default: toolchain-apikey
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    workspaces:
      - name: artifacts
        description: A workspace containing the test results file to pubslih to DOI
        mountPath: /artifacts
    stepTemplate:
      env:
        - name: PIPELINE_DEBUG
          value: $(params.pipeline-debug)
    steps:
      - name: publish-testrecord
        image: 'ibmcom/pipeline-base-image:2.6'
        env:
          - name: IBM_CLOUD_API
            value: $(params.ibmcloud-api)
          - name: IBM_CLOUD_API_KEY
            valueFrom:
              secretKeyRef:
                name: $(params.continuous-delivery-context-secret)
                key: $(params.toolchain-apikey-secret-key)
                optional: true
          - name: APP_NAME
            value: $(params.app-name)
          - name: TOOLCHAIN_ID
            value: $(params.toolchain-id)
          - name: BUILD_NUMBER
            value: $(params.build-number)
          - name: FILE_LOCATIONS
            value: $(params.file-locations)
          - name: TEST_TYPES
            value: $(params.test-types)
          - name: DEFAULT_BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
        workingDir: /artifacts
        script: >
          #!/bin/bash

          set -e -o pipefail


          if [ $PIPELINE_DEBUG == 1 ]; then
              pwd
              env
              trap env EXIT
              set -x
          fi


          ##########################################################################

          # Setting HOME explicitly to have ibmcloud plugins available

          # doing the export rather than env definition is a workaround

          # until https://github.com/tektoncd/pipeline/issues/1836 is fixed

          export HOME="/root"

          ##########################################################################

          if [[ "$IBM_CLOUD_API" == *test* ]]; then
            export IBM_CLOUD_DEVOPS_ENV=dev
          fi


          # Default Toolchain ID if needed

          if [ -z "$TOOLCHAIN_ID" ]; then
            TOOLCHAIN_ID=$(jq -r '.toolchain_guid' /cd-config/toolchain.json)
          fi


          # Default Job URL if needed

          if [ -z "$JOB_URL" ]; then
            JOB_URL="$PIPELINE_RUN_URL"
          fi


          # Default build number if needed

          if [ -z "$BUILD_NUMBER" ]; then
            BUILD_NUMBER="$DEFAULT_BUILD_NUMBER"
          fi


          if [ "$(params.environment)" ]; then
            ENVIRONMENT=" --env \"$(params.environment)\""
          else
            ENVIRONMENT=""
          fi


          export TOOLCHAIN_ID=${TOOLCHAIN_ID} # for doi plugin

          ibmcloud login --apikey ${IBM_CLOUD_API_KEY} -a ${IBM_CLOUD_API}
          --no-region


          IFS=';' read -ra locations <<< "$FILE_LOCATIONS"

          IFS=';' read -ra types <<< "$TEST_TYPES"

          for i in "${!locations[@]}"

          do
              # check if type exists for the given index. If not, keep the last found.
              if [[ "${types[i]}" ]]; then
                TEST_TYPE=${types[i]}
              fi
              echo "$i ${locations[i]} ${TEST_TYPE}"
              ibmcloud doi publishtestrecord --logicalappname="$APP_NAME" --buildnumber=$BUILD_NUMBER \
                --filelocation=${locations[i]} --type=${TEST_TYPE} $ENVIRONMENT
          done
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
    volumes:
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: linter-docker-lint
  spec:
    params:
      - name: path-to-dockerfile
        default: .
      - name: dockerfile
        description: The name of the Dockerfile
        default: Dockerfile
      - name: path-to-hadolint-config
        default: ''
      - name: hadolint-ignored-rules
        default: ''
      - name: trusted-registries
        default: ''
      - name: fail-on-lint-errors
        description: >
          flag (`true` | `false`) to indicate if the task should fail or
          continue

          if issues are found in the Dockerfile lint
        default: 'true'
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    workspaces:
      - name: workspace
        description: A workspace where the Dockerfile is expected to be
        mountPath: /artifacts
    steps:
      - name: check-dockerfile
        image: 'hadolint/hadolint:v1.18.0-alpine'
        workingDir: /artifacts
        env:
          - name: DOCKER_FILE
            value: $(params.dockerfile)
          - name: DOCKER_FILE_PATH
            value: $(params.path-to-dockerfile)
          - name: HADOLINT_CONFIG
            value: $(params.path-to-hadolint-config)
          - name: HADOLINT_IGNORED_RULES
            value: $(params.hadolint-ignored-rules)
          - name: TRUSTED_REGISTRIES
            value: $(params.trusted-registries)
          - name: PIPELINE_DEBUG
            value: $(params.pipeline-debug)
        script: >
          #!/bin/sh

          if [ $PIPELINE_DEBUG == 1 ]; then
            pwd
            env
            hadolint --version
            trap env EXIT
            set -x
          fi


          if [ -f ${DOCKER_FILE_PATH}/${DOCKER_FILE} ]; then
              echo -e "Dockerfile found at: ${DOCKER_FILE_PATH}/${DOCKER_FILE}"
          else
              echo "Dockerfile not found at: ${DOCKER_FILE_PATH}/${DOCKER_FILE}"
              exit 1
          fi


          echo "Linting Dockerfile"


          if [ "$HADOLINT_CONFIG" ]; then
            HADOLINT_CONFIG="--config $HADOLINT_CONFIG"
          fi


          if [ "$HADOLINT_IGNORED_RULES" ]; then
            HADOLINT_IGNORED_RULES=$(echo $HADOLINT_IGNORED_RULES | sed "s/,/ --ignore /g")
            HADOLINT_IGNORED_RULES="--ignore $HADOLINT_IGNORED_RULES"
          fi


          if [ "$TRUSTED_REGISTRIES" ]; then
            TRUSTED_REGISTRIES=$(echo $TRUSTED_REGISTRIES | sed "s/,/ --trusted-registry /g")
            TRUSTED_REGISTRIES="--trusted-registry $TRUSTED_REGISTRIES"
          fi


          if hadolint ${HADOLINT_CONFIG} ${HADOLINT_IGNORED_RULES}
          ${TRUSTED_REGISTRIES} ${DOCKER_FILE_PATH}/${DOCKER_FILE}; then
            echo "No lint errors found"
          else
            # Failures in the lint
            if [ "$(params.fail-on-lint-errors)" == "true" ]; then
              exit 1;
            fi
          fi
- apiVersion: tekton.dev/v1beta1
  kind: Task
  metadata:
    name: tester-run-tests
  spec:
    params:
      - name: pipeline-secret
        description: name of the secret containing secret values for the task
        default: secure-properties
      - name: pipeline-configmap
        description: name of the configmap containing values for the task
        default: environment-properties
      - name: tests-image
        default: 'ibmcom/pipeline-base-image:latest'
      - name: shuttle-properties-file
        description: file containing properties
        default: ''
      - name: tests-script
        default: ''
      - name: fail-on-test-errors
        description: >
          flag ("true" | "false") to indicate if the task should be marked as
          fail or successfull

          if _tests_ script is failing with exit not equal to 0. Default to
          "true"
        default: 'true'
      - name: pipeline-debug
        description: Pipeline debug mode
        default: '0'
    results:
      - name: tests-exit-code
        description: The exit-code of the tests script
      - name: test-result-file-paths
        description: semi-colon list of test result output file paths
      - name: test-types
        description: >-
          semi-colon separated list of of test types. Order should match file
          output paths in test-result-file-paths
    workspaces:
      - name: artifacts
        description: A workspace backing by a volume
        mountPath: /artifacts
    steps:
      - name: run-tests
        image: $(params.tests-image)
        workingDir: /artifacts
        env:
          - name: BUILD_NUMBER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/build-number'']'
          - name: PIPELINE_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/pipeline-id'']'
          - name: PIPELINE_STAGE_EXECUTION_ID
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/tekton-pipeline'']'
          - name: PIPELINE_TRIGGERING_USER
            valueFrom:
              fieldRef:
                fieldPath: 'metadata.annotations[''devops.cloud.ibm.com/triggered-by'']'
          - name: SHUTTLE_PROPERTIES_FILE
            value: $(params.shuttle-properties-file)
          - name: PIPELINE_DEBUG
            value: $(params.pipeline-debug)
        script: >
          #!/bin/bash

          set -e -o pipefail


          if [ $PIPELINE_DEBUG == 1 ]; then
              env
              pwd
              trap env EXIT
              set -x
          fi


          export PIPELINE_TOOLCHAIN_ID=$(jq -r '.toolchain_guid'
          /artifacts/_toolchain.json)


          if [ "$SHUTTLE_PROPERTIES_FILE" ]; then
            source $SHUTTLE_PROPERTIES_FILE
            export $(cut -d= -f1 $SHUTTLE_PROPERTIES_FILE)
          fi

          echo -n "" > $(results.test-result-file-paths.path)

          echo -n "" > $(results.test-types.path)

          printf "#!/bin/bash\n" > /steps/tests-script.sh

          printf "%s " '$(params.tests-script)' >> /steps/tests-script.sh

          chmod +x /steps/tests-script.sh


          if [ $PIPELINE_DEBUG == 1 ]; then
            echo "== cat /steps/tests-script.sh =="
            cat /steps/tests-script.sh
            echo "================================"
          fi


          if /steps/tests-script.sh; then
            echo -n $? > $(results.tests-exit-code.path)
            echo "Tests executed successfully"
          else
            echo -n $? > $(results.tests-exit-code.path)
            # Failures in the tests execution
            if [ "$(params.fail-on-test-errors)" == "true" ]; then
              echo "Tests failed [exit code: $(cat $(results.tests-exit-code.path))]"
              EXIT=$(cat $(results.tests-exit-code.path))
              exit $EXIT
            else
              echo "Tests failed [exit code: $(cat $(results.tests-exit-code.path))] but Task is configured to not fail"
            fi
          fi
        volumeMounts:
          - mountPath: /cd-config
            name: cd-config-volume
          - mountPath: /steps
            name: steps-volume
          - mountPath: /artifacts/_toolchain.json
            subPath: toolchain.json
            name: cd-config-volume
          - mountPath: /cd-config/secrets
            name: pipeline-secrets
          - mountPath: /cd-config/properties
            name: pipeline-properties
    volumes:
      - name: steps-volume
        emptyDir: {}
      - name: cd-config-volume
        configMap:
          name: toolchain
          items:
            - key: toolchain.json
              path: toolchain.json
      - name: pipeline-properties
        configMap:
          name: $(params.pipeline-configmap)
          optional: true
      - name: pipeline-secrets
        secret:
          secretName: $(params.pipeline-secret)
          optional: true
- apiVersion: tekton.dev/v1alpha1
  kind: Condition
  metadata:
    name: utils-evaluate
  spec:
    params:
      - name: value
      - name: condition
        default: =
      - name: expected
        default: 'true'
    check:
      image: alpine
      command:
        - /bin/sh
        - '-c'
      args:
        - >
          if [ "$(params.value)" $(params.condition) "$(params.expected)" ];
          then
            exit 0
          else
            exit 1
          fi
